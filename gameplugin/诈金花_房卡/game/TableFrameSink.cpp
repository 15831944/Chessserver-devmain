#include "StdAfx.h"
#include "TableFrameSink.h"
#include "DlgCustomRule.h"
#include <conio.h>
#include <locale>

//////////////////////////////////////////////////////////////////////////

//公共加密原文
unsigned char chCommonEncryption[AESENCRYPTION_LENGTH] =
{
    0x32, 0x43, 0xf6, 0xa8,
    0x88, 0x5a, 0x30, 0x8d,
    0x31, 0x31, 0x98, 0xa2,
    0xe0, 0x37, 0x07, 0x34
};

//静态变量
const BYTE			CTableFrameSink::m_GameStartMode = START_MODE_ALL_READY;	//开始模式

//房间玩家信息
CMap<DWORD, DWORD, ROOMUSERINFO, ROOMUSERINFO> g_MapRoomUserInfo;	//玩家USERID映射玩家信息
//房间用户控制
CList<ROOMUSERCONTROL, ROOMUSERCONTROL &> g_ListRoomUserControl;		//房间用户控制链表
//操作控制记录
CList<CString, CString &> g_ListOperationRecord;						//操作控制记录

ROOMUSERINFO	g_CurrentQueryUserInfo;								//当前查询用户信息

//全局变量
LONGLONG    g_lRoomStorageStart = 0LL;      //房间起始库存
LONGLONG    g_lRoomStorageCurrent = 0LL;    //总输赢分
LONGLONG    g_lStorageDeductRoom = 0LL;     //回扣变量
LONGLONG    g_lStoragePer0 = 0LL;           //库存<0赢概率
LONGLONG    g_lStoragePer1 = 0LL;           //库存<上限1赢概率
LONGLONG    g_lStorageMax1Room = 0LL;       //库存上限1
LONGLONG    g_lStorageMul1Room = 0LL;       //赢概率1
LONGLONG    g_lStorageMax2Room = 0LL;       //库存上限2
LONGLONG    g_lStorageMul2Room = 0LL;       //赢概率2


//定时器 0~30
#define IDI_ADD_SCORE						3									//结束定时器

#define TIME_GAME_COMPAREEND				6000								//结束定时器
#define TIME_GAME_OPENEND					6000								//结束定时器
#define TIME_ADD_SCORE						1000								//结束定时器

//////////////////////////////////////////////////////////////////////////

//构造函数
CTableFrameSink::CTableFrameSink()
{
    //游戏变量
    m_wPlayerCount = GAME_PLAYER;
    m_bOperaCount = 0;
    m_wBankerUser = INVALID_CHAIR;
    m_wCurrentUser = INVALID_CHAIR;
    m_lCompareCount = 0;
    m_bGameEnd = false;
    ZeroMemory(m_wFlashUser, sizeof(m_wFlashUser));

    //用户状态
    ZeroMemory(&m_StGameEnd, sizeof(m_StGameEnd));
    ZeroMemory(m_cbPlayStatus, sizeof(m_cbPlayStatus));
    ZeroMemory(m_cbGiveUpUser, sizeof(m_cbGiveUpUser));
    for(int i = 0; i < GAME_PLAYER; i++)
    {
        m_bMingZhu[i] = false;
        m_wCompardUser[i].RemoveAll();
    }
    ZeroMemory(m_cbRealPlayer, sizeof(m_cbRealPlayer));
    ZeroMemory(m_cbAndroidStatus, sizeof(m_cbAndroidStatus));

    //扑克变量
    ZeroMemory(m_cbHandCardData, sizeof(m_cbHandCardData));

    //下注信息
    m_lMaxCellScore = 0L;
    m_lCellScore = 0L;
    m_lCurrentTimes = 0L;
    ZeroMemory(m_lTableScore, sizeof(m_lTableScore));
    ZeroMemory(m_lUserMaxScore, sizeof(m_lUserMaxScore));

    //组件变量
    m_pITableFrame = NULL;
    m_pGameServiceOption = NULL;

    //清空链表
    g_ListRoomUserControl.RemoveAll();
    g_ListOperationRecord.RemoveAll();
    ZeroMemory(&g_CurrentQueryUserInfo, sizeof(g_CurrentQueryUserInfo));

    ZeroMemory(m_lostScoreInfo, sizeof(m_lostScoreInfo));

    //服务控制
    m_bUpdataStorage = false;
    m_hControlInst = NULL;
    m_pServerControl = NULL;
    m_hControlInst = LoadLibrary(TEXT("ZaJinHuaServerControl.dll"));
    if(m_hControlInst)
    {
        typedef void *(*CREATE)();
        CREATE ServerControl = (CREATE)GetProcAddress(m_hControlInst, "CreateServerControl");
        if(ServerControl)
        {
            m_pServerControl = static_cast<IServerControl *>(ServerControl());
        }
    }

    //游戏视频
    m_hVideoInst = NULL;
    m_pGameVideo = NULL;
    m_hVideoInst = LoadLibrary(TEXT("ZaJinHuaGameVideo.dll"));
    if(m_hVideoInst)
    {
        typedef void *(*CREATE)();
        CREATE GameVideo = (CREATE)GetProcAddress(m_hVideoInst, "CreateGameVideo");
        if(GameVideo)
        {
            m_pGameVideo = static_cast<IGameVideo *>(GameVideo());
        }
    }


    ZeroMemory(m_chUserAESKey, sizeof(m_chUserAESKey));

    ZeroMemory(&m_RoomCardRecord, sizeof(m_RoomCardRecord));

    //随机种子
    srand(time(NULL));

    return;
}

//析构函数
CTableFrameSink::~CTableFrameSink(void)
{
    if(m_pServerControl)
    {
        delete m_pServerControl;
        m_pServerControl = NULL;
    }

    if(m_hControlInst)
    {
        FreeLibrary(m_hControlInst);
        m_hControlInst = NULL;
    }

    if(m_pGameVideo)
    {
        delete m_pGameVideo;
        m_pGameVideo = NULL;
    }

    if(m_hVideoInst)
    {
        FreeLibrary(m_hVideoInst);
        m_hVideoInst = NULL;
    }
}

//释放对象
VOID CTableFrameSink::Release()
{
    if(m_pServerControl)
    {
        delete m_pServerControl;
        m_pServerControl = NULL;
    }

    if(m_hControlInst)
    {
        FreeLibrary(m_hControlInst);
        m_hControlInst = NULL;
    }

    delete this;
}

//接口查询--检测相关信息版本
void   *CTableFrameSink::QueryInterface(const IID &Guid, DWORD dwQueryVer)
{
    QUERYINTERFACE(ITableFrameSink, Guid, dwQueryVer);
    QUERYINTERFACE(ITableUserAction, Guid, dwQueryVer);
    QUERYINTERFACE_IUNKNOWNEX(ITableFrameSink, Guid, dwQueryVer);
    return NULL;
}

//初始化
bool  CTableFrameSink::Initialization(IUnknownEx *pIUnknownEx)
{
    //查询接口
    ASSERT(pIUnknownEx != NULL);
    m_pITableFrame = QUERY_OBJECT_PTR_INTERFACE(pIUnknownEx, ITableFrame);
    if(m_pITableFrame == NULL)
    {
        return false;
    }

    //开始模式
    m_pITableFrame->SetStartMode(START_MODE_ALL_READY);

    //获取参数
    m_pGameServiceOption = m_pITableFrame->GetGameServiceOption();
    ASSERT(m_pGameServiceOption != NULL);

    //读取配置
    ReadConfigInformation();

    bool bstatus = IsRoomCardScoreType();

    return true;
}

//复位桌子
void  CTableFrameSink::RepositionSink()
{
    //游戏变量
    m_bOperaCount = 0;
    m_wCurrentUser = INVALID_CHAIR;
    m_lCompareCount = 0;
    ZeroMemory(m_wFlashUser, sizeof(m_wFlashUser));

    //用户状态
    ZeroMemory(&m_StGameEnd, sizeof(m_StGameEnd));
    ZeroMemory(m_cbPlayStatus, sizeof(m_cbPlayStatus));
    ZeroMemory(m_cbGiveUpUser, sizeof(m_cbGiveUpUser));
    for(int i = 0; i < m_wPlayerCount; i++)
    {
        m_bMingZhu[i] = false;
        m_wCompardUser[i].RemoveAll();
    }
    ZeroMemory(m_cbRealPlayer, sizeof(m_cbRealPlayer));
    ZeroMemory(m_cbAndroidStatus, sizeof(m_cbAndroidStatus));

    //扑克变量
    ZeroMemory(m_cbHandCardData, sizeof(m_cbHandCardData));

    //下注信息
    m_lMaxCellScore = 0L;
    m_lCellScore = 0L;
    m_lCurrentTimes = 0L;
    ZeroMemory(m_lTableScore, sizeof(m_lTableScore));
    ZeroMemory(m_lUserMaxScore, sizeof(m_lUserMaxScore));

    ZeroMemory(m_lostScoreInfo, sizeof(m_lostScoreInfo));

    return;
}

//积分事件
bool CTableFrameSink::OnUserScroeNotify(WORD wChairID, IServerUserItem *pIServerUserItem, BYTE cbReason)
{
    //房卡金币房间,写分变化
    if(IsRoomCardTreasureType() && cbReason == SCORE_REASON_WRITE && !pIServerUserItem->IsAndroidUser())
    {
        LONGLONG lRoomCardTurnMaxScore = 0LL;

        //设置文件名
        TCHAR szPath[MAX_PATH] = TEXT("");
        TCHAR szFileName[MAX_PATH] = TEXT("");
        GetCurrentDirectory(sizeof(szPath), szPath);
        _sntprintf(szFileName, sizeof(szFileName), TEXT("%s\\ZaJinHuaRoomCard.ini"), szPath);

        //读取配置
        lRoomCardTurnMaxScore = GetPrivateProfileInt(m_pGameServiceOption->szServerName, TEXT("lTurnMaxScore"), 10000, szFileName);

        if(pIServerUserItem->GetUserScore() < lRoomCardTurnMaxScore)
        {
            m_pITableFrame->SendUserItemData(pIServerUserItem, SUB_S_RC_TREASEURE_DEFICIENCY);
        }
    }

    return false;
}

//开始模式
BYTE  CTableFrameSink::GetGameStartMode()
{
    return m_GameStartMode;
}

//游戏状态
bool  CTableFrameSink::IsUserPlaying(WORD wChairID)
{
    ASSERT(wChairID < m_wPlayerCount);
    return (m_cbPlayStatus[wChairID] == TRUE) ? true : false;
}

//用户断线
bool CTableFrameSink::OnActionUserOffLine(WORD wChairID, IServerUserItem *pIServerUserItem)
{
    //更新房间用户信息
    UpdateRoomUserInfo(pIServerUserItem, USER_OFFLINE);

    return true;
}

//游戏开始
bool  CTableFrameSink::OnEventGameStart()
{
    //删除定时器
    m_pITableFrame->KillGameTimer(IDI_ADD_SCORE);

    //设置状态
    m_pITableFrame->SetGameStatus(GAME_STATUS_PLAY);

    //私人房间
    if((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0)
    {
        //cbGameRule[1] 为  2 、3 、4 、5, 0分别对应 2人 、 3人 、 4人 、 5人 、 2-5人 这几种配置
        BYTE *pGameRule = m_pITableFrame->GetGameRule();
        if(pGameRule[1] != 0)
        {
            m_wPlayerCount = pGameRule[1];
            //设置人数
            m_pITableFrame->SetTableChairCount(m_wPlayerCount);
        }
        else
        {
            m_wPlayerCount = GAME_PLAYER;
            //设置人数
            m_pITableFrame->SetTableChairCount(GAME_PLAYER);
        }
    }

    //更新房间用户信息
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        //获取用户
        IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(pIServerUserItem != NULL)
        {
            UpdateRoomUserInfo(pIServerUserItem, USER_SITDOWN);
        }
    }

    m_bGameEnd = false;

    //最大下注
    LONGLONG lTimes = 6L;
    BYTE cbAiCount = 0;
    BYTE cbPlayCount = 0;

    //判断约占积分场
    LONGLONG lRoomCardTurnMaxScore = 0;
    LONGLONG lRoomCardMaxCellScore = 0;
    if(IsRoomCardScoreType())
    {
        tagZaJinHuaSpecial *pZaJinHuaSpecial = (tagZaJinHuaSpecial *)m_pGameServiceOption->cbPersonalRule;
        ASSERT(pZaJinHuaSpecial);

        //读取配置
        lRoomCardMaxCellScore = pZaJinHuaSpecial->lMaxCellScore_Score;
        lRoomCardTurnMaxScore = pZaJinHuaSpecial->lTurnMaxScore_Score;
    }

    if(IsRoomCardTreasureType())
    {
        tagZaJinHuaSpecial *pZaJinHuaSpecial = (tagZaJinHuaSpecial *)m_pGameServiceOption->cbPersonalRule;
        ASSERT(pZaJinHuaSpecial);

        //读取配置
        lRoomCardTurnMaxScore = pZaJinHuaSpecial->lTurnMaxScore_Treasure;
    }

    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        //获取用户
        IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(pIServerUserItem == NULL)
        {
            continue;
        }

        const LONGLONG lUserScore = pIServerUserItem->GetUserScore();

        //设置变量
        m_cbPlayStatus[i] = TRUE;

        if(IsRoomCardScoreType() && !IsRoomCardTreasureType())
        {
            m_lUserMaxScore[i] = min(lRoomCardTurnMaxScore, lUserScore);
        }
        else if(IsRoomCardTreasureType() && !IsRoomCardScoreType())
        {
            m_lUserMaxScore[i] = min(lRoomCardTurnMaxScore, lUserScore);
        }
        else
        {
            m_lUserMaxScore[i] = lUserScore;
        }

        //更新房间用户信息
        UpdateRoomUserInfo(pIServerUserItem, USER_SITDOWN);

        cbPlayCount++;
        if(pIServerUserItem->IsAndroidUser() == true)
        {
            cbAiCount++;
            m_cbAndroidStatus[i] = TRUE;
        }
        else
        {
            m_cbRealPlayer[i] = TRUE;
        }

        //判断单注
        LONGLONG Temp = lTimes;
        if(m_lUserMaxScore[i] < 10001)
        {
            Temp = 1L;
        }
        else if(m_lUserMaxScore[i] < 100001)
        {
            Temp = 2L;
        }
        else if(m_lUserMaxScore[i] < 1000001)
        {
            Temp = 3L;
        }
        else if(m_lUserMaxScore[i] < 10000001)
        {
            Temp = 4L;
        }
        else if(m_lUserMaxScore[i] < 100000001)
        {
            Temp = 5L;
        }
        if(lTimes > Temp)
        {
            lTimes = Temp;
        }
    }

    //库存
    if(g_lRoomStorageCurrent > 0 && NeedDeductStorage())
    {
        g_lRoomStorageCurrent = g_lRoomStorageCurrent - g_lRoomStorageCurrent * g_lStorageDeductRoom / 1000;
    }

    //发送库存消息
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        //获取用户
        IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(pIServerUserItem == NULL)
        {
            continue;
        }

        if(CUserRight::IsGameCheatUser(m_pITableFrame->GetTableUserItem(i)->GetUserRight()))
        {
            CString strInfo;
            strInfo.Format(TEXT("当前库存：%I64d"), g_lRoomStorageCurrent);

            m_pITableFrame->SendGameMessage(pIServerUserItem, strInfo, SMT_CHAT);
        }
    }

    //库存变量
    m_bUpdataStorage = (cbAiCount != cbPlayCount);
    //下注变量
    m_lCellScore = 1;
    //m_lCellScore=m_pGameServiceOption->lCellScore;
    while((lTimes--) > 0)
    {
        m_lCellScore *= 10;
    }

    //基础分数
    for(BYTE i = 0; i < m_wPlayerCount; i++)
    {
        if(m_lUserMaxScore[i] != 0)
        {
            m_lCellScore = __min(m_lUserMaxScore[i], m_lCellScore);
        }
    }

    m_lCurrentTimes = 1;
    m_lMaxCellScore = m_lCellScore * 10;

    if(!IsRoomCardScoreType() && !IsRoomCardTreasureType())
    {
        //最大下注
        for(WORD i = 0; i < m_wPlayerCount; i++)
        {
            if(m_cbPlayStatus[i] == TRUE)
            {
                m_lUserMaxScore[i] = __min(m_lUserMaxScore[i], m_lMaxCellScore * 101);
                if(m_pGameServiceOption->lRestrictScore != 0)
                {
                    m_lUserMaxScore[i] = __min(m_lUserMaxScore[i], m_pGameServiceOption->lRestrictScore);
                }
            }
        }
    }
    else if(IsRoomCardScoreType() && !IsRoomCardTreasureType())
    {
        m_lCellScore = 1;
        m_lMaxCellScore = lRoomCardMaxCellScore;
    }

    //分发扑克
    m_GameLogic.RandCardList(m_cbHandCardData[0], sizeof(m_cbHandCardData) / sizeof(m_cbHandCardData[0][0]));

    //游戏开始
    AnalyseStartCard();

#ifdef _DEBUG
    //m_cbHandCardData[0][0] = 0x32;
    //m_cbHandCardData[0][1] = 0x33;
    //m_cbHandCardData[0][2] = 0x34;
#endif
    //变量定义
    ROOMUSERCONTROL roomusercontrol;
    ZeroMemory(&roomusercontrol, sizeof(roomusercontrol));
    POSITION posKeyList;

    //控制
    if(m_pServerControl != NULL && AnalyseRoomUserControl(roomusercontrol, posKeyList))
    {
        //校验数据
        ASSERT(roomusercontrol.roomUserInfo.wChairID != INVALID_CHAIR && roomusercontrol.userControl.cbControlCount != 0
               && roomusercontrol.userControl.control_type != CONTINUE_CANCEL);

        if(m_pServerControl->ControlResult(m_cbHandCardData, roomusercontrol))
        {
            //获取元素
            ROOMUSERCONTROL &tmproomusercontrol = g_ListRoomUserControl.GetAt(posKeyList);

            //校验数据
            ASSERT(roomusercontrol.userControl.cbControlCount == tmproomusercontrol.userControl.cbControlCount);

            //控制局数
            tmproomusercontrol.userControl.cbControlCount--;

            CMD_S_UserControlComplete UserControlComplete;
            ZeroMemory(&UserControlComplete, sizeof(UserControlComplete));
            UserControlComplete.dwGameID = roomusercontrol.roomUserInfo.dwGameID;
            CopyMemory(UserControlComplete.szNickName, roomusercontrol.roomUserInfo.szNickName, sizeof(UserControlComplete.szNickName));
            UserControlComplete.controlType = roomusercontrol.userControl.control_type;
            UserControlComplete.cbRemainControlCount = tmproomusercontrol.userControl.cbControlCount;

            for(WORD i = 0; i < m_wPlayerCount; i++)
            {
                IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
                if(!pIServerUserItem)
                {
                    continue;
                }
                if(pIServerUserItem->IsAndroidUser() == true || CUserRight::IsGameCheatUser(pIServerUserItem->GetUserRight()) == false)
                {
                    continue;
                }

                //发送数据
                m_pITableFrame->SendTableData(i, SUB_S_USER_CONTROL_COMPLETE, &UserControlComplete, sizeof(UserControlComplete));
                m_pITableFrame->SendLookonData(i, SUB_S_USER_CONTROL_COMPLETE, &UserControlComplete, sizeof(UserControlComplete));

            }
        }
    }

	WORD wAiCount = 0;
	for (WORD i = 0; i<m_wPlayerCount; i++)
	{
		//获取用户
		IServerUserItem * pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
		if (pIServerUserItem != NULL)
		{
			if (m_cbPlayStatus[i] == FALSE)continue;
			if (pIServerUserItem->IsAndroidUser())
			{
				wAiCount++;
			}
		}
	}

    //机器人消息
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        //机器人数据
        IServerUserItem *pServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(pServerUserItem == NULL)
        {
            continue;
        }
        if(pServerUserItem->IsAndroidUser() == true)
        {
            //机器人数据
            CMD_S_AndroidCard AndroidCard ;
            ZeroMemory(&AndroidCard, sizeof(AndroidCard)) ;

            //设置变量
            AndroidCard.lStockScore = g_lRoomStorageCurrent;
            CopyMemory(AndroidCard.cbRealPlayer, m_cbRealPlayer, sizeof(m_cbRealPlayer));
            CopyMemory(AndroidCard.cbAndroidStatus, m_cbAndroidStatus, sizeof(m_cbAndroidStatus));
            CopyMemory(AndroidCard.cbAllHandCardData, m_cbHandCardData, sizeof(m_cbHandCardData));
			AndroidCard.wAndroidCount = wAiCount;
            m_pITableFrame->SendTableData(i, SUB_S_ANDROID_CARD, &AndroidCard, sizeof(AndroidCard));
        }
    }


    //设置庄家
    if(m_wBankerUser == INVALID_CHAIR)
    {
        m_wBankerUser = rand() % m_wPlayerCount;
    }

    //庄家离开
    if(m_wBankerUser < m_wPlayerCount && m_cbPlayStatus[m_wBankerUser] == FALSE)
    {
        m_wBankerUser = rand() % m_wPlayerCount;
    }

    //确定庄家
    while(m_cbPlayStatus[m_wBankerUser] == FALSE)
    {
        m_wBankerUser = (m_wBankerUser + 1) % m_wPlayerCount;
    }

    //用户设置
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        if(m_cbPlayStatus[i] == TRUE)
        {
            m_lTableScore[i] = m_lCellScore;
        }
    }

    //当前用户
    m_wCurrentUser = (m_wBankerUser + 1) % m_wPlayerCount;
    while(m_cbPlayStatus[m_wCurrentUser] == FALSE)
    {
        m_wCurrentUser = (m_wCurrentUser + 1) % m_wPlayerCount;
    }

    //构造数据
    CMD_S_GameStart GameStart;
    ZeroMemory(&GameStart, sizeof(GameStart));
    GameStart.lMaxScore = m_lMaxCellScore;
    GameStart.lCellScore = m_lCellScore;
    GameStart.lCurrentTimes = m_lCurrentTimes;
    GameStart.wCurrentUser = m_wCurrentUser;
    GameStart.wBankerUser = m_wBankerUser;
    CopyMemory(GameStart.cbPlayStatus, m_cbPlayStatus, sizeof(BYTE)*GAME_PLAYER);

    if(m_pGameVideo)
    {
        m_pGameVideo->StartVideo(m_pITableFrame, m_wPlayerCount);
    }

    bool bFirstRecord = true;

    WORD wRealPlayerCount = 0;
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        IServerUserItem *pServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(m_cbPlayStatus[i] == FALSE)
        {
            continue;
        }

        if(!pServerUserItem)
        {
            continue;
        }

        wRealPlayerCount++;
    }

    BYTE *pGameRule = m_pITableFrame->GetGameRule();

    //发送数据
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        IServerUserItem *pServerUserItem = m_pITableFrame->GetTableUserItem(i) ;
        if(m_cbPlayStatus[i] == TRUE)
        {
            GameStart.lUserMaxScore = m_lUserMaxScore[i];
            m_pITableFrame->SendTableData(i, SUB_S_GAME_START, &GameStart, sizeof(GameStart));

            if(m_pGameVideo)
            {
                Video_GameStart video;
                ZeroMemory(&video, sizeof(video));
                CopyMemory(video.cbHandCardData, m_cbHandCardData, sizeof(m_cbHandCardData));
                video.wPlayerCount = wRealPlayerCount;
                video.wGamePlayerCountRule = pGameRule[1];
                video.lMaxScore = m_lMaxCellScore;
                video.lCellScore = m_lCellScore;
                video.lCurrentTimes = m_lCurrentTimes;
                video.lUserMaxScore = GameStart.lUserMaxScore;
                video.wBankerUser = m_wBankerUser;
                video.wCurrentUser = m_wCurrentUser;
                CopyMemory(video.cbPlayStatus, m_cbPlayStatus, sizeof(m_cbPlayStatus));
                CopyMemory(video.szNickName, pServerUserItem->GetNickName(), sizeof(video.szNickName));
                video.wChairID = i;
                video.lScore = pServerUserItem->GetUserScore();

                m_pGameVideo->AddVideoData(SUB_S_GAME_START, &video, bFirstRecord);

                if(bFirstRecord == true)
                {
                    bFirstRecord = false;
                }
            }
        }
        m_pITableFrame->SendLookonData(i, SUB_S_GAME_START, &GameStart, sizeof(GameStart));
    }

    //服务控制
    if(m_pServerControl)
    {
        //服务信息
        BYTE cbHandCardData[GAME_PLAYER][MAX_COUNT];
        CopyMemory(cbHandCardData, m_cbHandCardData, sizeof(cbHandCardData));

        //排列扑克
        for(WORD i = 0; i < GAME_PLAYER; i++)
        {
            m_GameLogic.SortCardList(cbHandCardData[i], MAX_COUNT);
        }

        //信息结算
        m_pServerControl->ServerControl(cbHandCardData, m_pITableFrame, m_wPlayerCount);
    }

    //设置定时器 非房卡房间
    if(((m_pGameServiceOption->wServerType) & GAME_GENRE_PERSONAL) == 0)
    {
        m_pITableFrame->SetGameTimer(IDI_ADD_SCORE, TIME_ADD_SCORE * 40, 1, 0);
    }

    return true;
}

//游戏结束
bool CTableFrameSink::OnEventGameConclude(WORD wChairID, IServerUserItem *pIServerUserItem, BYTE cbReason)
{
    switch(cbReason)
    {
    case GER_COMPARECARD:	//比牌结束
    case GER_NO_PLAYER:		//没有玩家
    {
        if(m_bGameEnd)
        {
            return true;
        }
        m_bGameEnd = true;

        //定义变量
        CMD_S_GameEnd GameEnd;
        ZeroMemory(&GameEnd, sizeof(GameEnd));
        for(WORD i = 0; i < m_wPlayerCount; i++)
            for(WORD j = 0; j < 4; j++)
            {
                GameEnd.wCompareUser[i][j] = INVALID_CHAIR;
            }

        //唯一玩家
        WORD wWinner, wUserCount = 0;
        for(WORD i = 0; i < m_wPlayerCount; i++)
        {
            if(m_cbPlayStatus[i] == TRUE)
            {
                wUserCount++;
                wWinner = i;
                if(GER_COMPARECARD == cbReason)
                {
                    ASSERT(m_wBankerUser == i);
                }
                m_wBankerUser = i;
            }
        }

        //胜利者强退
        if(wUserCount == 0)
        {
            wWinner = m_wBankerUser;
        }

        //延迟开始
        bool bDelayOverGame = false;

        //计算总注
        LONGLONG lWinnerScore = 0L;
        for(WORD i = 0; i < m_wPlayerCount; i++)
        {
            if(i == wWinner)
            {
                continue;
            }
            GameEnd.lGameScore[i] = -m_lTableScore[i];
            lWinnerScore += m_lTableScore[i];
        }

        //处理税收
        GameEnd.lGameTax = m_pITableFrame->CalculateRevenue(wWinner, lWinnerScore);
        GameEnd.lGameScore[wWinner] = lWinnerScore - GameEnd.lGameTax;

        CopyMemory(GameEnd.cbCardData, m_cbHandCardData, sizeof(m_cbHandCardData));

        //扑克数据
        for(WORD i = 0; i < m_wPlayerCount; i++)
        {
            WORD wCount = 0;
            while(m_wCompardUser[i].GetCount() > 0)
            {
                GameEnd.wCompareUser[i][wCount++] = m_wCompardUser[i].GetAt(0);
                m_wCompardUser[i].RemoveAt(0);
            }
        }

        GameEnd.wEndState = 0;
        //修改积分
        tagScoreInfo ScoreInfo[GAME_PLAYER];
        ZeroMemory(ScoreInfo, sizeof(ScoreInfo));

        //胜利者强退
        if(wUserCount == 1)
        {
            for(WORD i = 0; i < m_wPlayerCount; i++)
            {
                if(m_cbPlayStatus[i] == FALSE)
                {
                    continue;
                }
                ScoreInfo[i].cbType = (GameEnd.lGameScore[i] > 0L) ? SCORE_TYPE_WIN : SCORE_TYPE_LOSE;
                ScoreInfo[i].lRevenue = GameEnd.lGameTax;
                ScoreInfo[i].lScore = GameEnd.lGameScore[i];

                if(ScoreInfo[i].cbType == SCORE_TYPE_LOSE && bDelayOverGame == false)
                {
                    IServerUserItem *pUserItem = m_pITableFrame->GetTableUserItem(i);
                    if(pUserItem != NULL && (pUserItem->GetUserScore() + GameEnd.lGameScore[i]) < m_pGameServiceOption->lMinTableScore)
                    {
                        bDelayOverGame = true;
                    }
                }

                //房卡模式
                if(((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0) && (m_RoomCardRecord.nCount < MAX_RECORD_COUNT))
                {
                    m_RoomCardRecord.lDetailScore[i][m_RoomCardRecord.nCount] = ScoreInfo[i].lScore;
                }
            }


            //房卡模式
            if((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0)
            {
                m_RoomCardRecord.nCount++;
            }
        }

        //库存统计
        for(WORD i = 0; i < m_wPlayerCount; i++)
        {
            //获取用户
            IServerUserItem *pIServerUserIte = m_pITableFrame->GetTableUserItem(i);
            if(pIServerUserIte == NULL)
            {
                continue;
            }
            if(!m_cbPlayStatus[i])
            {
                continue;
            }

            //库存累计
            if(!pIServerUserIte->IsAndroidUser())
            {
				CString str;
				str.Format(TEXT("真人玩家A [%s], 得分 %I64d 更新库存,下注 %I64d"), pIServerUserIte->GetNickName(), GameEnd.lGameScore[i], m_lTableScore[i]);
				WriteInfo(L"", str);

                UpdateStorage(-GameEnd.lGameScore[i]);    //g_lRoomStorageCurrent -= GameEnd.lGameScore[i];
            }

        }
        //房间类型
        GameEnd.wServerType = m_pGameServiceOption->wServerType;
        //延迟开始
        if(bDelayOverGame)
        {
            GameEnd.bDelayOverGame = true;
        }

        //if(wChairID == GAME_PLAYER)
        //{
        //    //结束数据
        //    CopyMemory(&m_StGameEnd, &GameEnd, sizeof(m_StGameEnd));

        //}
        //else
        {
            //发送信息
            m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_GAME_END, &GameEnd, sizeof(GameEnd));
            m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_GAME_END, &GameEnd, sizeof(GameEnd));

            if(m_pGameVideo)
            {
                m_pGameVideo->AddVideoData(SUB_S_GAME_END, &GameEnd);
                m_pGameVideo->StopAndSaveVideo(m_pGameServiceOption->wServerID, m_pITableFrame->GetTableID());
            }

            //写分
            for(WORD i = 0; i < m_wPlayerCount; i++)
            {
				if (m_cbPlayStatus[i] == FALSE && m_pITableFrame->GetTableUserItem(i) != NULL && m_lostScoreInfo[i].cbType != SCORE_TYPE_NULL)
                {
                    m_pITableFrame->WriteUserScore(i, m_lostScoreInfo[i]);
                }
                else if(m_cbPlayStatus[i] == TRUE && m_pITableFrame->GetTableUserItem(i) != NULL)
                {
                    m_pITableFrame->WriteUserScore(i, ScoreInfo[i]);
                }
            }

            // 检测发送喇叭
            CMD_GC_GTrumpet sTrumpet;
            for (WORD i=0; i<GAME_PLAYER; i++) {
                IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
                if(!pIServerUserItem) {
                    continue;
                }
                if (GameEnd.lGameScore[i] > 0) {
                    ZeroMemory(&sTrumpet, sizeof(sTrumpet));
                    sTrumpet.dwCardType = m_GameLogic.GetCardType(GameEnd.cbCardData[i], MAX_COUNT);
                    sTrumpet.lScore = GameEnd.lGameScore[i];
                    m_pITableFrame->SendUserItemData(pIServerUserItem, SUB_S_WIN_TRUMPET, &sTrumpet, sizeof(sTrumpet));
                }
            }

            //房卡模式
            if((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0)
            {
                CMD_S_RoomCardRecord RoomCardRecord;
                ZeroMemory(&RoomCardRecord, sizeof(RoomCardRecord));

                CopyMemory(&RoomCardRecord, &m_RoomCardRecord, sizeof(m_RoomCardRecord));

                m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));
                m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));
            }

            //检查机器人存储款
            for(WORD i = 0; i < m_wPlayerCount; i++)
            {
                //获取用户
                IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
                if(!pIServerUserItem)
                {
                    continue;
                }
                if(!pIServerUserItem->IsAndroidUser())
                {
                    continue;
                }
                m_pITableFrame->SendTableData(i, SUB_S_ANDROID_BANKOPERATOR);
            }

            //结束游戏
            m_pITableFrame->ConcludeGame(GAME_STATUS_FREE);
            m_pITableFrame->SetGameStatus(GAME_STATUS_FREE);
        }

        //更新房间用户信息
        for(WORD i = 0; i < m_wPlayerCount; i++)
        {
            //获取用户
            IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);

            if(!pIServerUserItem)
            {
                continue;
            }

            UpdateRoomUserInfo(pIServerUserItem, USER_SITDOWN);
        }

        //房卡模式
        if(((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0) && m_pITableFrame->IsPersonalRoomDisumme())
        {
            //约战解散
            ZeroMemory(&m_RoomCardRecord, sizeof(m_RoomCardRecord));
        }

        return true;
    }
    case GER_USER_LEAVE:		//用户强退
    case GER_NETWORK_ERROR:		//网络中断
    {
        if(m_bGameEnd || m_cbPlayStatus[wChairID] == FALSE)
        {
            return true;
        }

        //效验参数
        ASSERT(pIServerUserItem != NULL);
        ASSERT(wChairID < m_wPlayerCount);

        //CString str;
        //str.Format(TEXT("【%d桌】 %d退出放弃"), m_pITableFrame->GetTableID() + 1, m_wCurrentUser);
        //NcaTextOut(str, m_pGameServiceOption->szServerName);

        //强退处理
        return OnUserGiveUp(wChairID, true);
    }
    case GER_DISMISS:		//游戏解散
    {
        //变量定义
        CMD_S_GameEnd GameEnd;
        ZeroMemory(&GameEnd, sizeof(GameEnd));

        //发送信息
        m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_GAME_END, &GameEnd, sizeof(GameEnd));
        m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_GAME_END, &GameEnd, sizeof(GameEnd));

        //if(m_pGameVideo)
        //{
        //	m_pGameVideo->AddVideoData(SUB_S_GAME_END,&GameEnd);
        //	m_pGameVideo->StopAndSaveVideo(m_pGameServiceOption->wServerID,m_pITableFrame->GetTableID());
        //}

        //结束游戏
        m_pITableFrame->ConcludeGame(GAME_STATUS_FREE);
        m_pITableFrame->SetGameStatus(GAME_STATUS_FREE);

        //更新房间用户信息
        for(WORD i = 0; i < m_wPlayerCount; i++)
        {
            //获取用户
            IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);

            if(!pIServerUserItem)
            {
                continue;
            }

            UpdateRoomUserInfo(pIServerUserItem, USER_STANDUP);
        }

        return true;
    }
    }

    return false;
}

//发送场景
bool  CTableFrameSink::OnEventSendGameScene(WORD wChairID, IServerUserItem *pIServerUserItem, BYTE cbGameStatus, bool bSendSecret)
{
    switch(cbGameStatus)
    {
    case GAME_STATUS_FREE:		//空闲状态
    {
        //构造数据
        CMD_S_StatusFree StatusFree;
        ZeroMemory(&StatusFree, sizeof(StatusFree));

        //设置变量
        StatusFree.lCellScore = 0L;
        StatusFree.lRoomStorageStart = g_lRoomStorageStart;
        StatusFree.lRoomStorageCurrent = g_lRoomStorageCurrent;

        //获取自定义配置
        tagCustomRule *pCustomRule = (tagCustomRule *)m_pGameServiceOption->cbCustomRule;
        ASSERT(pCustomRule);
        tagCustomAndroid CustomAndroid;
        ZeroMemory(&CustomAndroid, sizeof(CustomAndroid));
        CustomAndroid.lRobotBankGet = pCustomRule->lRobotBankGet;
        CustomAndroid.lRobotBankGetBanker = pCustomRule->lRobotBankGetBanker;
        CustomAndroid.lRobotBankStoMul = pCustomRule->lRobotBankStoMul;
        CustomAndroid.lRobotScoreMax = pCustomRule->lRobotScoreMax;
        CustomAndroid.lRobotScoreMin = pCustomRule->lRobotScoreMin;
        CopyMemory(&StatusFree.CustomAndroid, &CustomAndroid, sizeof(CustomAndroid));
        BYTE *pGameRule = m_pITableFrame->GetGameRule();
        StatusFree.wGamePlayerCountRule = pGameRule[1];

        if(pIServerUserItem->GetUserStatus() != US_LOOKON)
        {
            CopyMemory(StatusFree.chUserAESKey, m_chUserAESKey[wChairID], sizeof(m_chUserAESKey[wChairID]));
        }

        CopyMemory(StatusFree.szServerName, m_pGameServiceOption->szServerName, sizeof(StatusFree.szServerName));

        //房卡模式
        if((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0)
        {
            CMD_S_RoomCardRecord RoomCardRecord;
            ZeroMemory(&RoomCardRecord, sizeof(RoomCardRecord));

            CopyMemory(&RoomCardRecord, &m_RoomCardRecord, sizeof(m_RoomCardRecord));

            m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));
            m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));
        }

        //发送场景
        return m_pITableFrame->SendGameScene(pIServerUserItem, &StatusFree, sizeof(StatusFree));
    }
    case GAME_STATUS_PLAY:	//游戏状态
    {
        //构造数据
        CMD_S_StatusPlay StatusPlay;
        memset(&StatusPlay, 0, sizeof(StatusPlay));

        //加注信息
        StatusPlay.lMaxCellScore = m_lMaxCellScore;
        StatusPlay.lCellScore = m_lCellScore;
        StatusPlay.lCurrentTimes = m_lCurrentTimes;
        StatusPlay.lUserMaxScore = m_lUserMaxScore[wChairID];

        //设置变量
        StatusPlay.wBankerUser = m_wBankerUser;
        StatusPlay.wCurrentUser = m_wCurrentUser;
        CopyMemory(StatusPlay.bMingZhu, m_bMingZhu, sizeof(m_bMingZhu));
        CopyMemory(StatusPlay.lTableScore, m_lTableScore, sizeof(m_lTableScore));
        CopyMemory(StatusPlay.cbPlayStatus, m_cbPlayStatus, sizeof(m_cbPlayStatus));
        StatusPlay.lRoomStorageStart = g_lRoomStorageStart;
        StatusPlay.lRoomStorageCurrent = g_lRoomStorageCurrent;

        //获取自定义配置
        tagCustomRule *pCustomRule = (tagCustomRule *)m_pGameServiceOption->cbCustomRule;
        ASSERT(pCustomRule);
        tagCustomAndroid CustomAndroid;
        ZeroMemory(&CustomAndroid, sizeof(CustomAndroid));
        CustomAndroid.lRobotBankGet = pCustomRule->lRobotBankGet;
        CustomAndroid.lRobotBankGetBanker = pCustomRule->lRobotBankGetBanker;
        CustomAndroid.lRobotBankStoMul = pCustomRule->lRobotBankStoMul;
        CustomAndroid.lRobotScoreMax = pCustomRule->lRobotScoreMax;
        CustomAndroid.lRobotScoreMin = pCustomRule->lRobotScoreMin;
        CopyMemory(&StatusPlay.CustomAndroid, &CustomAndroid, sizeof(CustomAndroid));
        BYTE *pGameRule = m_pITableFrame->GetGameRule();
        StatusPlay.wGamePlayerCountRule = pGameRule[1];

        //当前状态
        StatusPlay.bCompareState = (m_lCompareCount <= 0) ? false : true;

        //设置扑克
        if(m_bMingZhu[wChairID])
        {
            CopyMemory(&StatusPlay.cbHandCardData, &m_cbHandCardData[wChairID], MAX_COUNT);
        }

        //更新房间用户信息
        UpdateRoomUserInfo(pIServerUserItem, USER_RECONNECT);

        if(pIServerUserItem->GetUserStatus() != US_LOOKON)
        {
            CopyMemory(StatusPlay.chUserAESKey, m_chUserAESKey[wChairID], sizeof(m_chUserAESKey[wChairID]));
        }

        CopyMemory(StatusPlay.szServerName, m_pGameServiceOption->szServerName, sizeof(StatusPlay.szServerName));

        //房卡模式
        if((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0)
        {
            CMD_S_RoomCardRecord RoomCardRecord;
            ZeroMemory(&RoomCardRecord, sizeof(RoomCardRecord));

            CopyMemory(&RoomCardRecord, &m_RoomCardRecord, sizeof(m_RoomCardRecord));

            m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));
            m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));
        }

        //发送场景
        return m_pITableFrame->SendGameScene(pIServerUserItem, &StatusPlay, sizeof(StatusPlay));
    }
    }

    //效验错误
    ASSERT(FALSE);

    return false;
}

//定时器事件
bool  CTableFrameSink::OnTimerMessage(DWORD wTimerID, WPARAM wBindParam)
{
    if(wTimerID == IDI_ADD_SCORE)
    {
        m_pITableFrame->KillGameTimer(IDI_ADD_SCORE);
        if(m_wCurrentUser != INVALID_CHAIR)
        {
            OnUserGiveUp(m_wCurrentUser, false);

            //CString str;
            //str.Format(TEXT("【%d桌】 %d超时放弃"), m_pITableFrame->GetTableID() + 1, m_wCurrentUser);
            //NcaTextOut(str, m_pGameServiceOption->szServerName);
        }
    }

    return false;
}

//游戏消息处理
bool  CTableFrameSink::OnGameMessage(WORD wSubCmdID, VOID *pData, WORD wDataSize, IServerUserItem *pIServerUserItem)
{
    switch(wSubCmdID)
    {
    case SUB_C_GIVE_UP:			//用户放弃
    {
        //用户效验
        tagUserInfo *pUserData = pIServerUserItem->GetUserInfo();
        if(pUserData->cbUserStatus != US_PLAYING)
        {
            return true;
        }

        //状态判断
        ASSERT(m_cbPlayStatus[pUserData->wChairID] == TRUE);
        if(m_cbPlayStatus[pUserData->wChairID] == FALSE)
        {
            return false;
        }

        //消息处理
        return OnUserGiveUp(pUserData->wChairID);
    }
    case SUB_C_LOOK_CARD:		//用户看牌
    {
        //用户效验
        tagUserInfo *pUserData = pIServerUserItem->GetUserInfo();
        if(pUserData->cbUserStatus != US_PLAYING)
        {
            return true;
        }

        //状态判断
        ASSERT(m_cbPlayStatus[pUserData->wChairID] == TRUE);
        if(m_cbPlayStatus[pUserData->wChairID] == FALSE)
        {
            return true;
        }

        //消息处理
        return OnUserLookCard(pUserData->wChairID);
    }
    case SUB_C_COMPARE_CARD:	//用户比牌
    {
        //效验数据
        ASSERT(wDataSize == sizeof(CMD_C_CompareCard));
        if(wDataSize != sizeof(CMD_C_CompareCard))
        {
            return false;
        }

        //变量定义
        CMD_C_CompareCard *pCompareCard = (CMD_C_CompareCard *)pData;

        //用户效验
        tagUserInfo *pUserData = pIServerUserItem->GetUserInfo();
        if(pUserData->cbUserStatus != US_PLAYING)
        {
            return true;
        }

        //参数效验
        ASSERT(pUserData->wChairID == m_wCurrentUser);
        if(pUserData->wChairID != m_wCurrentUser)
        {
            return false;
        }

        //状态判断
        ASSERT(m_cbPlayStatus[pUserData->wChairID] == TRUE && m_cbPlayStatus[pCompareCard->wCompareUser] == TRUE);
        if(m_cbPlayStatus[pUserData->wChairID] == FALSE || m_cbPlayStatus[pCompareCard->wCompareUser] == FALSE)
        {
            return false;
        }

        //消息处理
        return OnUserCompareCard(pUserData->wChairID, pCompareCard->wCompareUser);
    }
    case SUB_C_ADD_SCORE:		//用户加注
    {
        //效验数据
        ASSERT(wDataSize == sizeof(CMD_C_AddScore));
        if(wDataSize != sizeof(CMD_C_AddScore))
        {
            return false;
        }

        //变量定义
        CMD_C_AddScore *pAddScore = (CMD_C_AddScore *)pData;

        //用户效验
        tagUserInfo *pUserData = pIServerUserItem->GetUserInfo();
        if(pUserData->cbUserStatus != US_PLAYING)
        {
            return true;
        }

        //状态判断
        ASSERT(m_cbPlayStatus[pUserData->wChairID] == TRUE && m_lCompareCount == 0);
        if(m_cbPlayStatus[pUserData->wChairID] == FALSE || m_lCompareCount > 0)
        {
            return false;
        }

        //当前状态
        if(pAddScore->wState > 0)
        {
            m_lCompareCount = pAddScore->lScore;
        }

        //消息处理
        return OnUserAddScore(pUserData->wChairID, pAddScore->lScore, false, ((pAddScore->wState > 0) ? true : false), pAddScore->chciphertext);
    }
    case SUB_C_WAIT_COMPARE:	//等待比牌
    {
        //用户效验
        tagUserInfo *pUserData = pIServerUserItem->GetUserInfo();
        if(pUserData->cbUserStatus != US_PLAYING)
        {
            return true;
        }

        //状态判断
        ASSERT(m_cbPlayStatus[pUserData->wChairID] == TRUE);
        if(m_cbPlayStatus[pUserData->wChairID] == FALSE)
        {
            return false;
        }

        //参数效验
        ASSERT(pUserData->wChairID == m_wCurrentUser);
        if(pUserData->wChairID != m_wCurrentUser)
        {
            return false;
        }

        //消息处理
        CMD_S_WaitCompare WaitCompare;
        WaitCompare.wCompareUser = pUserData->wChairID;
        if(m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_WAIT_COMPARE, &WaitCompare, sizeof(WaitCompare)) &&
                m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_WAIT_COMPARE, &WaitCompare, sizeof(WaitCompare)))

        {
            return true;
        }
    }
    case SUB_C_FINISH_FLASH:	//完成动画
    {
        //用户效验
        tagUserInfo *pUserData = pIServerUserItem->GetUserInfo();
        if(pUserData->cbUserStatus != US_PLAYING)
        {
            return true;
        }

        //状态判断
        ASSERT(m_wFlashUser[pUserData->wChairID] == TRUE);
        if(m_wFlashUser[pUserData->wChairID] == FALSE)
        {
            return true;
        }

        //设置变量
        m_wFlashUser[pUserData->wChairID] = FALSE;

        //结束游戏
        WORD i = 0;
        for(; i < GAME_PLAYER; i++)
        {
            if(m_wFlashUser[i] != FALSE)
            {
                break;
            }
        }
        if(i == GAME_PLAYER)
        {
            //发送信息
            m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_GAME_END, &m_StGameEnd, sizeof(m_StGameEnd));
            m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_GAME_END, &m_StGameEnd, sizeof(m_StGameEnd));

            if(m_pGameVideo)
            {
                m_pGameVideo->AddVideoData(SUB_S_GAME_END, &m_StGameEnd);
                m_pGameVideo->StopAndSaveVideo(m_pGameServiceOption->wServerID, m_pITableFrame->GetTableID());
            }

            for(WORD i = 0; i < m_wPlayerCount; i++)
            {
				if (m_cbPlayStatus[i] == FALSE && m_pITableFrame->GetTableUserItem(i) != NULL && m_lostScoreInfo[i].cbType != SCORE_TYPE_NULL)
                {
                    m_pITableFrame->WriteUserScore(i, m_lostScoreInfo[i]);
                }
                else if(m_cbPlayStatus[i] == TRUE && m_pITableFrame->GetTableUserItem(i) != NULL)
                {
                    tagScoreInfo ScoreInfo;
                    ZeroMemory(&ScoreInfo, sizeof(ScoreInfo));

                    ScoreInfo.cbType = (m_StGameEnd.lGameScore[i] > 0L) ? SCORE_TYPE_WIN : SCORE_TYPE_LOSE;
                    ScoreInfo.lRevenue = m_StGameEnd.lGameTax;
                    ScoreInfo.lScore = m_StGameEnd.lGameScore[i];

                    m_pITableFrame->WriteUserScore(i, ScoreInfo);
                }
            }

			//检查机器人存储款
			for (WORD i = 0; i < m_wPlayerCount; i++)
			{
				//获取用户
				IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
				if (!pIServerUserItem)
				{
					continue;
				}
				if (!pIServerUserItem->IsAndroidUser())
				{
					continue;
				}
				m_pITableFrame->SendTableData(i, SUB_S_ANDROID_BANKOPERATOR);
			}

            //房卡模式
            if((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0)
            {
                CMD_S_RoomCardRecord RoomCardRecord;
                ZeroMemory(&RoomCardRecord, sizeof(RoomCardRecord));

                CopyMemory(&RoomCardRecord, &m_RoomCardRecord, sizeof(m_RoomCardRecord));

                m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));
                m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));
            }

            //结束游戏
            m_pITableFrame->ConcludeGame(GAME_STATUS_FREE);
            m_pITableFrame->SetGameStatus(GAME_STATUS_FREE);
        }
        return true;
    }
    case SUB_C_REQUEST_RCRecord:
    {
        ASSERT(((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0) && (!m_pITableFrame->IsPersonalRoomDisumme()));
        if(!(((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0) && (!m_pITableFrame->IsPersonalRoomDisumme())))
        {
            return false;
        }

        CMD_S_RoomCardRecord RoomCardRecord;
        ZeroMemory(&RoomCardRecord, sizeof(RoomCardRecord));

        CopyMemory(&RoomCardRecord, &m_RoomCardRecord, sizeof(m_RoomCardRecord));

        m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_ROOMCARD_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));

        return true;
    }
        // 	case SUB_C_ADD_SCORE_TIME:
        // 		{
        // 			//用户效验
        // 			tagUserInfo * pUserData=pIServerUserItem->GetUserInfo();
        // 			if (pUserData->cbUserStatus!=US_PLAYING) return true;
        //
        // 			m_pITableFrame->SetGameTimer(IDI_ADD_SCORE,TIME_ADD_SCORE*30,1,0);
        // 			return true;
        // 		}
    }

    return false;
}

//框架消息处理
bool  CTableFrameSink::OnFrameMessage(WORD wSubCmdID, VOID *pData, WORD wDataSize, IServerUserItem *pIServerUserItem)
{
    // 消息处理
    if(wSubCmdID >= SUB_GF_FRAME_MESSAG_GAME_MIN && wSubCmdID <= SUB_GF_FRAME_MESSAG_GAME_MAX)
    {
        switch(wSubCmdID - SUB_GF_FRAME_MESSAG_GAME_MIN)
        {
        case SUB_C_STORAGE:
        {
            ASSERT(wDataSize == sizeof(CMD_C_UpdateStorage));
            if(wDataSize != sizeof(CMD_C_UpdateStorage))
            {
                return false;
            }

            //权限判断
            if(CUserRight::IsGameCheatUser(pIServerUserItem->GetUserRight()) == false)
            {
                return false;
            }

            CMD_C_UpdateStorage *pUpdateStorage = (CMD_C_UpdateStorage *)pData;
            g_lRoomStorageCurrent = pUpdateStorage->lRoomStorageCurrent;
            g_lStorageDeductRoom = pUpdateStorage->lRoomStorageDeduct;

            //20条操作记录
            if(g_ListOperationRecord.GetSize() == MAX_OPERATION_RECORD)
            {
                g_ListOperationRecord.RemoveHead();
            }

            CString strOperationRecord;
            strOperationRecord.Format(TEXT("控制账户[%s],修改当前库存为 %I64d,衰减值为 %I64d"),
                pIServerUserItem->GetNickName(), g_lRoomStorageCurrent, g_lStorageDeductRoom);

            g_ListOperationRecord.AddTail(strOperationRecord);

            //写入日志
            WriteInfo(L"", strOperationRecord);

            //变量定义
            CMD_S_Operation_Record OperationRecord;
            ZeroMemory(&OperationRecord, sizeof(OperationRecord));
            POSITION posListRecord = g_ListOperationRecord.GetHeadPosition();
            WORD wIndex = 0;//数组下标
            while(posListRecord)
            {
                CString strRecord = g_ListOperationRecord.GetNext(posListRecord);

                CopyMemory(OperationRecord.szRecord[wIndex], strRecord, sizeof(OperationRecord.szRecord[wIndex]));
                wIndex++;
            }

            ASSERT(wIndex <= MAX_OPERATION_RECORD);

            //发送数据
            m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_OPERATION_RECORD, &OperationRecord, sizeof(OperationRecord));

            return true;
        }
        case SUB_C_STORAGEMAXMUL:
        {
            ASSERT(wDataSize == sizeof(CMD_C_ModifyStorage));
            if(wDataSize != sizeof(CMD_C_ModifyStorage))
            {
                return false;
            }

            //权限判断
            if(CUserRight::IsGameCheatUser(pIServerUserItem->GetUserRight()) == false)
            {
                return false;
            }

            CMD_C_ModifyStorage *pModifyStorage = (CMD_C_ModifyStorage *)pData;
            g_lStorageMax1Room = pModifyStorage->lMaxRoomStorage[0];
            g_lStorageMax2Room = pModifyStorage->lMaxRoomStorage[1];
            g_lStorageMul1Room = (SCORE)(pModifyStorage->wRoomStorageMul[0]);
            g_lStorageMul2Room = (SCORE)(pModifyStorage->wRoomStorageMul[1]);
            g_lStoragePer0 = (SCORE)(pModifyStorage->wRoomStoragePer0);
            g_lStoragePer1 = (SCORE)(pModifyStorage->wRoomStoragePer1);

            //20条操作记录
            if(g_ListOperationRecord.GetSize() == MAX_OPERATION_RECORD)
            {
                g_ListOperationRecord.RemoveHead();
            }

            CString strOperationRecord;
            strOperationRecord.Format(TEXT("控制账户[%s], 修改库存上限值1为 %I64d,赢分概率1为 %I64d,上限值2为 %I64d,赢分概率2为 %I64d"),
                pIServerUserItem->GetNickName(), g_lStorageMax1Room, g_lStorageMul1Room, g_lStorageMax2Room, g_lStorageMul2Room);

            g_ListOperationRecord.AddTail(strOperationRecord);

            //写入日志
            WriteInfo(L"", strOperationRecord);

            //变量定义
            CMD_S_Operation_Record OperationRecord;
            ZeroMemory(&OperationRecord, sizeof(OperationRecord));
            POSITION posListRecord = g_ListOperationRecord.GetHeadPosition();
            WORD wIndex = 0;//数组下标
            while(posListRecord)
            {
                CString strRecord = g_ListOperationRecord.GetNext(posListRecord);

                CopyMemory(OperationRecord.szRecord[wIndex], strRecord, sizeof(OperationRecord.szRecord[wIndex]));
                wIndex++;
            }

            ASSERT(wIndex <= MAX_OPERATION_RECORD);

            //发送数据
            m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_OPERATION_RECORD, &OperationRecord, sizeof(OperationRecord));

            return true;
        }
        case SUB_C_REQUEST_QUERY_USER:
        {
            ASSERT(wDataSize == sizeof(CMD_C_RequestQuery_User));
            if(wDataSize != sizeof(CMD_C_RequestQuery_User))
            {
                return false;
            }

            //权限判断
            if(CUserRight::IsGameCheatUser(pIServerUserItem->GetUserRight()) == false || pIServerUserItem->IsAndroidUser())
            {
                return false;
            }

            CMD_C_RequestQuery_User *pQuery_User = (CMD_C_RequestQuery_User *)pData;

            //遍历映射
            POSITION ptHead = g_MapRoomUserInfo.GetStartPosition();
            DWORD dwUserID = 0;
            ROOMUSERINFO userinfo;
            ZeroMemory(&userinfo, sizeof(userinfo));

            CMD_S_RequestQueryResult QueryResult;
            ZeroMemory(&QueryResult, sizeof(QueryResult));

            while(ptHead)
            {
                g_MapRoomUserInfo.GetNextAssoc(ptHead, dwUserID, userinfo);
                if(pQuery_User->dwGameID == userinfo.dwGameID || _tcscmp(pQuery_User->szNickName, userinfo.szNickName) == 0)
                {
                    //拷贝用户信息数据
                    QueryResult.bFind = true;
                    CopyMemory(&(QueryResult.userinfo), &userinfo, sizeof(userinfo));

                    ZeroMemory(&g_CurrentQueryUserInfo, sizeof(g_CurrentQueryUserInfo));
                    CopyMemory(&(g_CurrentQueryUserInfo), &userinfo, sizeof(userinfo));
                }
            }

            //发送数据
            m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_REQUEST_QUERY_RESULT, &QueryResult, sizeof(QueryResult));

            return true;
        }
        case SUB_C_USER_CONTROL:
        {
            ASSERT(wDataSize == sizeof(CMD_C_UserControl));
            if(wDataSize != sizeof(CMD_C_UserControl))
            {
                return false;
            }

            //权限判断
            if(CUserRight::IsGameCheatUser(pIServerUserItem->GetUserRight()) == false || pIServerUserItem->IsAndroidUser() == true)
            {
                return false;
            }

            CMD_C_UserControl *pUserControl = (CMD_C_UserControl *)pData;

            //遍历映射
            POSITION ptMapHead = g_MapRoomUserInfo.GetStartPosition();
            DWORD dwUserID = 0;
            ROOMUSERINFO userinfo;
            ZeroMemory(&userinfo, sizeof(userinfo));

            //20条操作记录
            if(g_ListOperationRecord.GetSize() == MAX_OPERATION_RECORD)
            {
                g_ListOperationRecord.RemoveHead();
            }

            //变量定义
            CMD_S_UserControl serverUserControl;
            ZeroMemory(&serverUserControl, sizeof(serverUserControl));

            TCHAR szNickName[LEN_NICKNAME];
            ZeroMemory(szNickName, sizeof(szNickName));

            //激活控制
            if(pUserControl->userControlInfo.bCancelControl == false)
            {
                ASSERT(pUserControl->userControlInfo.control_type == CONTINUE_WIN || pUserControl->userControlInfo.control_type == CONTINUE_LOST);

                while(ptMapHead)
                {
                    g_MapRoomUserInfo.GetNextAssoc(ptMapHead, dwUserID, userinfo);

                    if(_tcscmp(pUserControl->szNickName, szNickName) == 0 && _tcscmp(userinfo.szNickName, szNickName) == 0)
                    {
                        continue;
                    }

                    if(pUserControl->dwGameID == userinfo.dwGameID || _tcscmp(pUserControl->szNickName, userinfo.szNickName) == 0)
                    {
                        //激活控制标识
                        bool bEnableControl = false;
                        IsSatisfyControl(userinfo, bEnableControl);

                        //满足控制
                        if(bEnableControl)
                        {
                            ROOMUSERCONTROL roomusercontrol;
                            ZeroMemory(&roomusercontrol, sizeof(roomusercontrol));
                            CopyMemory(&(roomusercontrol.roomUserInfo), &userinfo, sizeof(userinfo));
                            CopyMemory(&(roomusercontrol.userControl), &(pUserControl->userControlInfo), sizeof(roomusercontrol.userControl));


                            //遍历链表，除重
                            TravelControlList(roomusercontrol);

                            //压入链表（不压入同GAMEID和NICKNAME)
                            g_ListRoomUserControl.AddHead(roomusercontrol);

                            //复制数据
                            serverUserControl.dwGameID = userinfo.dwGameID;
                            CopyMemory(serverUserControl.szNickName, userinfo.szNickName, sizeof(userinfo.szNickName));
                            serverUserControl.controlResult = CONTROL_SUCCEED;
                            serverUserControl.controlType = pUserControl->userControlInfo.control_type;
                            serverUserControl.cbControlCount = pUserControl->userControlInfo.cbControlCount;

                            //操作记录
                            CString strOperationRecord;
                            CString strControlType;
                            GetControlTypeString(serverUserControl.controlType, strControlType);
                            CTime time = CTime::GetCurrentTime();
                            strOperationRecord.Format(TEXT("操作时间: %d/%d/%d-%d:%d:%d, 控制账户[%s], 控制玩家%s,%s,控制局数%d "),
                                                      time.GetYear(), time.GetMonth(), time.GetDay(), time.GetHour(), time.GetMinute(), time.GetSecond(), pIServerUserItem->GetNickName(), serverUserControl.szNickName, strControlType, serverUserControl.cbControlCount);

                            g_ListOperationRecord.AddTail(strOperationRecord);

                            //写入日志
                            WriteInfo(L"", strOperationRecord);
                        }
                        else	//不满足
                        {
                            //复制数据
                            serverUserControl.dwGameID = userinfo.dwGameID;
                            CopyMemory(serverUserControl.szNickName, userinfo.szNickName, sizeof(userinfo.szNickName));
                            serverUserControl.controlResult = CONTROL_FAIL;
                            serverUserControl.controlType = pUserControl->userControlInfo.control_type;
                            serverUserControl.cbControlCount = 0;

                            //操作记录
                            CString strOperationRecord;
                            CString strControlType;
                            GetControlTypeString(serverUserControl.controlType, strControlType);
                            CTime time = CTime::GetCurrentTime();
                            strOperationRecord.Format(TEXT("操作时间: %d/%d/%d-%d:%d:%d, 控制账户[%s], 控制玩家%s,%s,失败！"),
                                                      time.GetYear(), time.GetMonth(), time.GetDay(), time.GetHour(), time.GetMinute(), time.GetSecond(), pIServerUserItem->GetNickName(), serverUserControl.szNickName, strControlType);

                            g_ListOperationRecord.AddTail(strOperationRecord);

                            //写入日志
                            WriteInfo(L"", strOperationRecord);
                        }

                        //发送数据
                        m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_USER_CONTROL, &serverUserControl, sizeof(serverUserControl));

                        CMD_S_Operation_Record OperationRecord;
                        ZeroMemory(&OperationRecord, sizeof(OperationRecord));
                        POSITION posListRecord = g_ListOperationRecord.GetHeadPosition();
                        WORD wIndex = 0;//数组下标
                        while(posListRecord)
                        {
                            CString strRecord = g_ListOperationRecord.GetNext(posListRecord);

                            CopyMemory(OperationRecord.szRecord[wIndex], strRecord, sizeof(OperationRecord.szRecord[wIndex]));
                            wIndex++;
                        }

                        ASSERT(wIndex <= MAX_OPERATION_RECORD);

                        //发送数据
                        m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_OPERATION_RECORD, &OperationRecord, sizeof(OperationRecord));

                        return true;
                    }
                }

                ASSERT(FALSE);
                return false;
            }
            else	//取消控制
            {
                ASSERT(pUserControl->userControlInfo.control_type == CONTINUE_CANCEL);

                POSITION ptListHead = g_ListRoomUserControl.GetHeadPosition();
                POSITION ptTemp;
                ROOMUSERCONTROL roomusercontrol;
                ZeroMemory(&roomusercontrol, sizeof(roomusercontrol));

                //遍历链表
                while(ptListHead)
                {
                    ptTemp = ptListHead;
                    roomusercontrol = g_ListRoomUserControl.GetNext(ptListHead);
                    if(pUserControl->dwGameID == roomusercontrol.roomUserInfo.dwGameID || _tcscmp(pUserControl->szNickName, roomusercontrol.roomUserInfo.szNickName) == 0)
                    {
                        //复制数据
                        serverUserControl.dwGameID = roomusercontrol.roomUserInfo.dwGameID;
                        CopyMemory(serverUserControl.szNickName, roomusercontrol.roomUserInfo.szNickName, sizeof(roomusercontrol.roomUserInfo.szNickName));
                        serverUserControl.controlResult = CONTROL_CANCEL_SUCCEED;
                        serverUserControl.controlType = pUserControl->userControlInfo.control_type;
                        serverUserControl.cbControlCount = 0;

                        //移除元素
                        g_ListRoomUserControl.RemoveAt(ptTemp);

                        //发送数据
                        m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_USER_CONTROL, &serverUserControl, sizeof(serverUserControl));

                        //操作记录
                        CString strOperationRecord;
                        CTime time = CTime::GetCurrentTime();
                        strOperationRecord.Format(TEXT("操作时间: %d/%d/%d-%d:%d:%d, 控制账户[%s], 取消对玩家%s的控制！"),
                                                  time.GetYear(), time.GetMonth(), time.GetDay(), time.GetHour(), time.GetMinute(), time.GetSecond(), pIServerUserItem->GetNickName(), serverUserControl.szNickName);

                        g_ListOperationRecord.AddTail(strOperationRecord);

                        //写入日志
                        WriteInfo(L"", strOperationRecord);

                        CMD_S_Operation_Record OperationRecord;
                        ZeroMemory(&OperationRecord, sizeof(OperationRecord));
                        POSITION posListRecord = g_ListOperationRecord.GetHeadPosition();
                        WORD wIndex = 0;//数组下标
                        while(posListRecord)
                        {
                            CString strRecord = g_ListOperationRecord.GetNext(posListRecord);

                            CopyMemory(OperationRecord.szRecord[wIndex], strRecord, sizeof(OperationRecord.szRecord[wIndex]));
                            wIndex++;
                        }

                        ASSERT(wIndex <= MAX_OPERATION_RECORD);

                        //发送数据
                        m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_OPERATION_RECORD, &OperationRecord, sizeof(OperationRecord));

                        return true;
                    }
                }

                //复制数据
                serverUserControl.dwGameID = pUserControl->dwGameID;
                CopyMemory(serverUserControl.szNickName, pUserControl->szNickName, sizeof(serverUserControl.szNickName));
                serverUserControl.controlResult = CONTROL_CANCEL_INVALID;
                serverUserControl.controlType = pUserControl->userControlInfo.control_type;
                serverUserControl.cbControlCount = 0;

                //发送数据
                m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_USER_CONTROL, &serverUserControl, sizeof(serverUserControl));

                //操作记录
                CString strOperationRecord;
                CTime time = CTime::GetCurrentTime();
                strOperationRecord.Format(TEXT("操作时间: %d/%d/%d-%d:%d:%d, 控制账户[%s], 取消对玩家%s的控制，操作无效！"),
                                          time.GetYear(), time.GetMonth(), time.GetDay(), time.GetHour(), time.GetMinute(), time.GetSecond(), pIServerUserItem->GetNickName(), serverUserControl.szNickName);

                g_ListOperationRecord.AddTail(strOperationRecord);

                //写入日志
                WriteInfo(L"", strOperationRecord);

                CMD_S_Operation_Record OperationRecord;
                ZeroMemory(&OperationRecord, sizeof(OperationRecord));
                POSITION posListRecord = g_ListOperationRecord.GetHeadPosition();
                WORD wIndex = 0;//数组下标
                while(posListRecord)
                {
                    CString strRecord = g_ListOperationRecord.GetNext(posListRecord);

                    CopyMemory(OperationRecord.szRecord[wIndex], strRecord, sizeof(OperationRecord.szRecord[wIndex]));
                    wIndex++;
                }

                ASSERT(wIndex <= MAX_OPERATION_RECORD);

                //发送数据
                m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_OPERATION_RECORD, &OperationRecord, sizeof(OperationRecord));

            }

            return true;
        }
        case SUB_C_REQUEST_UDPATE_ROOMINFO:
        {
            //权限判断
            if(CUserRight::IsGameCheatUser(pIServerUserItem->GetUserRight()) == false || pIServerUserItem->IsAndroidUser() == true)
            {
                return false;
            }

            CMD_S_ADMIN_STORAGE_INFO StorageInfo;
            ZeroMemory(&StorageInfo, sizeof(StorageInfo));
            StorageInfo.lRoomStorageStart = g_lRoomStorageStart;
            StorageInfo.lRoomStorageCurrent = g_lRoomStorageCurrent;
            StorageInfo.lRoomStorageDeduct = g_lStorageDeductRoom;
            StorageInfo.lMaxRoomStorage[0] = g_lStorageMax1Room;
            StorageInfo.lMaxRoomStorage[1] = g_lStorageMax2Room;
            StorageInfo.wRoomStorageMul[0] = (WORD)g_lStorageMul1Room;
            StorageInfo.wRoomStorageMul[1] = (WORD)g_lStorageMul2Room;
            StorageInfo.wRoomStoragePer0 = (WORD)g_lStoragePer0;
            StorageInfo.wRoomStoragePer1 = (WORD)g_lStoragePer1;

            //发送数据
            m_pITableFrame->SendRoomData(pIServerUserItem, SUB_S_ADMIN_STORAGE_INFO, &StorageInfo, sizeof(StorageInfo));


            return true;
        }
        case SUB_C_CLEAR_CURRENT_QUERYUSER:
        {
            //权限判断
            if(CUserRight::IsGameCheatUser(pIServerUserItem->GetUserRight()) == false || pIServerUserItem->IsAndroidUser() == true)
            {
                return false;
            }

            ZeroMemory(&g_CurrentQueryUserInfo, sizeof(g_CurrentQueryUserInfo));

            return true;
        }
        }
    }
    return false;
}



//用户坐下
bool CTableFrameSink::OnActionUserSitDown(WORD wChairID, IServerUserItem *pIServerUserItem, bool bLookonUser)
{
    //更新房间用户信息
    UpdateRoomUserInfo(pIServerUserItem, USER_SITDOWN);

    //更新同桌用户控制
    UpdateUserControl(pIServerUserItem);

    //初始化密钥
    if(!bLookonUser)
    {
        m_chUserAESKey[wChairID][0] = (HIBYTE(HIWORD(pIServerUserItem->GetUserID())));
        m_chUserAESKey[wChairID][1] = (LOBYTE(HIWORD(pIServerUserItem->GetUserID())));
        m_chUserAESKey[wChairID][2] = (HIBYTE(LOWORD(pIServerUserItem->GetUserID())));
        m_chUserAESKey[wChairID][3] = (LOBYTE(LOWORD(pIServerUserItem->GetUserID())));
        m_chUserAESKey[wChairID][4] = rand() % 256;
        m_chUserAESKey[wChairID][5] = rand() % 256;
        m_chUserAESKey[wChairID][6] = rand() % 256;
        m_chUserAESKey[wChairID][7] = rand() % 256;
        m_chUserAESKey[wChairID][8] = rand() % 256;
        m_chUserAESKey[wChairID][9] = rand() % 256;
        m_chUserAESKey[wChairID][10] = rand() % 256;
        m_chUserAESKey[wChairID][11] = rand() % 256;
        m_chUserAESKey[wChairID][12] = rand() % 256;
        m_chUserAESKey[wChairID][13] = rand() % 256;
        m_chUserAESKey[wChairID][14] = rand() % 256;
        m_chUserAESKey[wChairID][15] = rand() % 256;
    }

    return true;
}

//用户起立
bool CTableFrameSink::OnActionUserStandUp(WORD wChairID, IServerUserItem *pIServerUserItem, bool bLookonUser)
{
    //更新房间用户信息
    UpdateRoomUserInfo(pIServerUserItem, USER_STANDUP);

    if(!bLookonUser)
    {
        //清除密钥
        ZeroMemory(m_chUserAESKey[wChairID], sizeof(m_chUserAESKey[wChairID]));
    }

    //约战解散
    if(((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0) && m_pITableFrame->IsPersonalRoomDisumme())
    {
        ZeroMemory(&m_RoomCardRecord, sizeof(m_RoomCardRecord));
    }

    return true;
}

//用户同意
bool CTableFrameSink::OnActionUserOnReady(WORD wChairID, IServerUserItem *pIServerUserItem, VOID *pData, WORD wDataSize)
{
    //私人房设置游戏模式
    if(((m_pGameServiceOption->wServerType) & GAME_GENRE_PERSONAL) != 0)
    {
        //cbGameRule[1] 为  2 、3 、4 、5, 0分别对应 2人 、 3人 、 4人 、 5人 、 2-5人 这几种配置
        BYTE *pGameRule = m_pITableFrame->GetGameRule();
        switch(pGameRule[1])
        {
        case 2:
        case 3:
        case 4:
        case 5:
        {
            if(m_pITableFrame->GetStartMode() != START_MODE_FULL_READY)
            {
                m_pITableFrame->SetStartMode(START_MODE_FULL_READY);
            }

            break;
        }
        case 0:
        {
            if(m_pITableFrame->GetStartMode() != START_MODE_ALL_READY)
            {
                m_pITableFrame->SetStartMode(START_MODE_ALL_READY);
            }
            break;
        }
        default:
            ASSERT(false);

        }
    }

    return true;
}

//放弃事件
bool CTableFrameSink::OnUserGiveUp(WORD wChairID, bool bExit)
{
    //设置数据
    m_cbGiveUpUser[wChairID] = TRUE;
    m_cbPlayStatus[wChairID] = FALSE;

    //发送消息
    CMD_S_GiveUp GiveUp;
    GiveUp.wGiveUpUser = wChairID;
    m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_GIVE_UP, &GiveUp, sizeof(GiveUp));
    m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_GIVE_UP, &GiveUp, sizeof(GiveUp));

    if(m_pGameVideo)
    {
        m_pGameVideo->AddVideoData(SUB_S_GIVE_UP, &GiveUp);
    }

    //修改积分
    tagScoreInfo ScoreInfo;
    ZeroMemory(&ScoreInfo, sizeof(ScoreInfo));
    ScoreInfo.cbType = (bExit) ? SCORE_TYPE_FLEE : SCORE_TYPE_LOSE;
    ScoreInfo.lRevenue = 0;
    ScoreInfo.lScore = -m_lTableScore[wChairID];

    CopyMemory(&m_lostScoreInfo[wChairID], &ScoreInfo, sizeof(ScoreInfo));

    //房卡模式
    if(((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0) && (m_RoomCardRecord.nCount < MAX_RECORD_COUNT))
    {
        m_RoomCardRecord.lDetailScore[wChairID][m_RoomCardRecord.nCount] = ScoreInfo.lScore;
    }

    //获取用户
    IServerUserItem *pIServerUserIte = m_pITableFrame->GetTableUserItem(wChairID);

    //库存统计
    if((pIServerUserIte != NULL) && (!pIServerUserIte->IsAndroidUser()))
    {
		CString str;
		str.Format(TEXT("真人玩家B [%s], 得分 %I64d 更新库存 下注 %I64d\n"), pIServerUserIte->GetNickName(), -m_lTableScore[wChairID], m_lTableScore[wChairID]);
		WriteInfo(L"", str);

        UpdateStorage(m_lTableScore[wChairID]);    //g_lRoomStorageCurrent += m_lTableScore[wChairID];
    }

    //人数统计
    WORD wPlayerCount = 0;
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        if(m_cbPlayStatus[i] == TRUE)
        {
            wPlayerCount++;
        }
    }

    //判断结束
    if(wPlayerCount >= 2)
    {
        unsigned char	chciphertext[AESENCRYPTION_LENGTH];
        ZeroMemory(chciphertext, sizeof(chciphertext));
        if(m_wCurrentUser == wChairID)
        {
            OnUserAddScore(wChairID, 0L, true, false, chciphertext);
        }

		m_pITableFrame->WriteUserScore(wChairID, m_lostScoreInfo[wChairID]);
		ZeroMemory(&m_lostScoreInfo[wChairID], sizeof(m_lostScoreInfo[wChairID]));
    }
    else
    {
        OnEventGameConclude(INVALID_CHAIR, NULL, GER_NO_PLAYER);
    }

    return true;
}

//看牌事件
bool CTableFrameSink::OnUserLookCard(WORD wChairID)
{
    //状态效验
    ASSERT(m_wCurrentUser == wChairID);
    if(m_wCurrentUser != wChairID)
    {
        CString strdebug;
        strdebug.Format(TEXT("KEVINZ 断线为%d"), m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser() ? TRUE : FALSE);
        WriteInfo(L"", strdebug);

        return true;
    }

    //参数效验
    ASSERT(!m_bMingZhu[wChairID]);
    if(m_bMingZhu[wChairID])
    {
        return true;
    }

    //设置参数
    m_bMingZhu[wChairID] = true;
    //构造数据
    CMD_S_LookCard LookCard;
    ZeroMemory(&LookCard, sizeof(LookCard));
    LookCard.wLookCardUser = wChairID;

    m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_LOOK_CARD, &LookCard, sizeof(LookCard));

    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(pIServerUserItem == NULL)
        {
            continue;
        }
        if(i == wChairID)
        {
            CopyMemory(LookCard.cbCardData, m_cbHandCardData[wChairID], sizeof(m_cbHandCardData[0]));
        }
        else
        {
            ZeroMemory(LookCard.cbCardData, sizeof(LookCard.cbCardData));
        }
        m_pITableFrame->SendTableData(i, SUB_S_LOOK_CARD, &LookCard, sizeof(LookCard));
    }

    if(m_pGameVideo)
    {
        m_pGameVideo->AddVideoData(SUB_S_LOOK_CARD, &LookCard);
    }

    return true;
}

//比牌事件
bool CTableFrameSink::OnUserCompareCard(WORD wFirstChairID, WORD wNextChairID)
{
    //效验参数
    ASSERT(m_lCompareCount > 0);
    if(!(m_lCompareCount > 0))
    {
        return false;
    }
    //LONGLONG lTemp=(m_bMingZhu[m_wCurrentUser])?6:5;
    //ASSERT((m_lUserMaxScore[m_wCurrentUser]-m_lTableScore[m_wCurrentUser]+m_lCompareCount) >= (m_lMaxCellScore*lTemp));
    //if((m_lUserMaxScore[m_wCurrentUser]-m_lTableScore[m_wCurrentUser]+m_lCompareCount) < (m_lMaxCellScore*lTemp))return false;
    //原来>=2*m_lCellScore，如果第一轮都的积分都没能达到加注跟注的条件，那么只能开牌，而底注就是m_lCellScore，
    //那么比牌就一定会掉线，此时m_lTableScore[m_wCurrentUser]为底注+m_lCompareCount。
    //至于为什么要大于等于2*m_lCellScore，原因不明
    ASSERT(m_wCurrentUser == m_wBankerUser || m_lTableScore[m_wCurrentUser] - m_lCompareCount >= m_lCellScore);
    if(!(m_wCurrentUser == m_wBankerUser || m_lTableScore[m_wCurrentUser] - m_lCompareCount >= m_lCellScore))
    {
        return false;
    }

    //删除定时器
    m_pITableFrame->KillGameTimer(IDI_ADD_SCORE);

    //比较大小
    BYTE cbWin = m_GameLogic.CompareCard(m_cbHandCardData[wFirstChairID], m_cbHandCardData[wNextChairID], MAX_COUNT);

    //状态设置
    m_lCompareCount = 0;

    //胜利用户
    WORD wLostUser, wWinUser;
    if(cbWin == TRUE)
    {
        wWinUser = wFirstChairID;
        wLostUser = wNextChairID;
    }
    else
    {
        wWinUser = wNextChairID;
        wLostUser = wFirstChairID;
    }

    //设置数据
    m_wCompardUser[wLostUser].Add(wWinUser);
    m_wCompardUser[wWinUser].Add(wLostUser);
    m_cbPlayStatus[wLostUser] = FALSE;

    //人数统计
    WORD wPlayerCount = 0;
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        if(m_cbPlayStatus[i] == TRUE)
        {
            wPlayerCount++;
        }
    }

    //继续游戏
    if(wPlayerCount >= 2)
    {
        //用户切换
        WORD wNextPlayer = INVALID_CHAIR;
        for(WORD i = 1; i < m_wPlayerCount; i++)
        {
            //设置变量
            wNextPlayer = (m_wCurrentUser + i) % m_wPlayerCount;

            //继续判断
            if(m_cbPlayStatus[wNextPlayer] == TRUE)
            {
                break;
            }
        }
        //设置用户
        m_wCurrentUser = wNextPlayer;
    }
    else
    {
        m_wCurrentUser = INVALID_CHAIR;
    }

    //构造数据
    CMD_S_CompareCard CompareCard;
    CompareCard.wCurrentUser = m_wCurrentUser;
    CompareCard.wLostUser = wLostUser;
    CompareCard.wCompareUser[0] = wFirstChairID;
    CompareCard.wCompareUser[1] = wNextChairID;

    //发送数据
    m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_COMPARE_CARD, &CompareCard, sizeof(CompareCard));
    m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_COMPARE_CARD, &CompareCard, sizeof(CompareCard));

    if(m_pGameVideo)
    {
        m_pGameVideo->AddVideoData(SUB_S_COMPARE_CARD, &CompareCard);
    }

    //修改积分
    tagScoreInfo ScoreInfo;
    ZeroMemory(&ScoreInfo, sizeof(ScoreInfo));
    ScoreInfo.cbType = SCORE_TYPE_LOSE;
    ScoreInfo.lRevenue = 0;
    ScoreInfo.lScore = -m_lTableScore[wLostUser];

    CopyMemory(&m_lostScoreInfo[wLostUser], &ScoreInfo, sizeof(ScoreInfo));

    //房卡模式
    if(((m_pGameServiceOption->wServerType & GAME_GENRE_PERSONAL) != 0) && (m_RoomCardRecord.nCount < MAX_RECORD_COUNT))
    {
        m_RoomCardRecord.lDetailScore[wLostUser][m_RoomCardRecord.nCount] = ScoreInfo.lScore;
    }

    //库存统计
    IServerUserItem *pIServreUserItemLost = m_pITableFrame->GetTableUserItem(wLostUser);
    if((pIServreUserItemLost != NULL) && (!pIServreUserItemLost->IsAndroidUser()))
    {
		CString str;
		str.Format(TEXT("真人玩家C [%s], 得分 %I64d 更新库存 下注 %I64d"), pIServreUserItemLost->GetNickName(), -m_lTableScore[wLostUser], m_lTableScore[wLostUser]);
		WriteInfo(L"", str);

        UpdateStorage(m_lTableScore[wLostUser]);    //g_lRoomStorageCurrent += m_lTableScore[wLostUser];
    }

    //结束游戏
    if(wPlayerCount < 2)
    {
        m_wBankerUser = wWinUser;
        m_wFlashUser[wNextChairID] = TRUE;
        m_wFlashUser[wFirstChairID] = TRUE;
        OnEventGameConclude(GAME_PLAYER, NULL, GER_COMPARECARD);
    }
	else
	{
		m_pITableFrame->WriteUserScore(wLostUser, m_lostScoreInfo[wLostUser]);
		ZeroMemory(&m_lostScoreInfo[wLostUser], sizeof(m_lostScoreInfo[wLostUser]));
	}

    return true;
}

//加注事件
bool CTableFrameSink::OnUserAddScore(WORD wChairID, LONGLONG lScore, bool bGiveUp, bool bCompareCard, unsigned char	chciphertext[AESENCRYPTION_LENGTH])
{
    if(bGiveUp == false)				//设置数据
    {
        //解密操作
        AESEncrypt aes(m_chUserAESKey[wChairID]);
        aes.InvCipher(chciphertext);

        //校验数据
        for(WORD i = 0; i < AESENCRYPTION_LENGTH; i++)
        {
            if(chCommonEncryption[i] != chciphertext[i])
            {
                //打印作弊名单
                IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(wChairID);
                if(pIServerUserItem != NULL)
                {
                    CString strtip;
                    strtip.Format(TEXT("玩家[%s] USERID为%d 作弊"), pIServerUserItem->GetNickName(), pIServerUserItem->GetUserID());
                    WriteInfo(L"", strtip);
                }

                return false;
            }
        }

        //状态效验
        //ASSERT(m_wCurrentUser == wChairID);
        if(m_wCurrentUser != wChairID)
        {
            CString strdebug;
            strdebug.Format(TEXT("KEVINA 断线为%d"), m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser() ? TRUE : FALSE);
            WriteInfo(L"", strdebug);

            if(m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser())
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        //金币效验
        //ASSERT(lScore >= 0 && lScore % m_lCellScore == 0);
        //ASSERT((lScore + m_lTableScore[wChairID]) <= m_lUserMaxScore[wChairID]);
        if(lScore < 0 || lScore % m_lCellScore != 0)
        {
            CString strdebug;
            strdebug.Format(TEXT("KEVINB 断线为%d"), m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser() ? TRUE : FALSE);
            WriteInfo(L"", strdebug);

            if(m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser())
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        if((lScore + m_lTableScore[wChairID]) > m_lUserMaxScore[wChairID])
        {
            CString strdebug;
            strdebug.Format(TEXT("KEVINC 断线为%d, 本轮下注【%I64d】 已下注【%I64d】 最大下注【%I64d】 携带金币【%I64d】 \n"), m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser() ? TRUE : FALSE
                            , lScore, m_lTableScore[wChairID], m_lUserMaxScore[wChairID], m_pITableFrame->GetTableUserItem(wChairID)->GetUserScore());

            //当前人数
            BYTE UserCount = 0;
            for(BYTE i = 0; i < GAME_PLAYER; i++)
            {
                if(m_cbPlayStatus[i] == TRUE)
                {
                    UserCount++;
                }
            }

            CString strInfo;
            strInfo.Format(TEXT("是否明牌 %d, m_lCurrentTimes【%I64d】 m_lCellScore【%I64d】 UserCount【%d】"), (m_bMingZhu[wChairID] ? TRUE : FALSE), m_lCurrentTimes, m_lCellScore, UserCount);
            strdebug += strInfo;
            WriteInfo(L"", strdebug);

            //if (m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser())
            //{
            //	return true;
            //}
            //else
            //{
            //	return false;
            //}
            return true;
        }

        IServerUserItem *pIserberUser = m_pITableFrame->GetTableUserItem(wChairID);
        if(pIserberUser->GetUserScore() < m_lTableScore[wChairID] + lScore)
        {
            CString strdebug;
            strdebug.Format(TEXT("KEVIND 断线为%d"), m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser() ? TRUE : FALSE);
            WriteInfo(L"", strdebug);

            if(m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser())
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        //当前倍数
        LONGLONG lTimes = (m_bMingZhu[wChairID] || bCompareCard) ? 2 : 1;
        if(m_bMingZhu[wChairID] && bCompareCard)
        {
            lTimes = 4;
        }
        LONGLONG lTemp = lScore / m_lCellScore / lTimes;
        //ASSERT(m_lCurrentTimes <= lTemp && m_lCurrentTimes <= m_lMaxCellScore / m_lCellScore);
        if(!(m_lCurrentTimes <= lTemp && m_lCurrentTimes <= m_lMaxCellScore / m_lCellScore))
        {
            CString strdebug;
            strdebug.Format(TEXT("KEVINE 断线为%d"), m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser() ? TRUE : FALSE);
            WriteInfo(L"", strdebug);

            if(m_pITableFrame->GetTableUserItem(wChairID)->IsAndroidUser())
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        m_lCurrentTimes = lTemp;

        //用户注金
        m_lTableScore[wChairID] += lScore;
    }

    //设置用户
    if(!bCompareCard)
    {
        //用户切换
        WORD wNextPlayer = INVALID_CHAIR;
        for(WORD i = 1; i < m_wPlayerCount; i++)
        {
            //设置变量
            wNextPlayer = (m_wCurrentUser + i) % m_wPlayerCount;

            //继续判断
            if(m_cbPlayStatus[wNextPlayer] == TRUE)
            {
                break;
            }
        }
        m_wCurrentUser = wNextPlayer;
    }

    //乱序密钥
    unsigned char chTempRandAesKey[AESKEY_VARIABLECOUNT];
    ZeroMemory(chTempRandAesKey, sizeof(chTempRandAesKey));
    RandAESKey(chTempRandAesKey, AESKEY_VARIABLECOUNT);

    //更新密钥
    CopyMemory(&m_chUserAESKey[wChairID][AESKEY_TOTALCOUNT - AESKEY_VARIABLECOUNT], chTempRandAesKey, sizeof(chTempRandAesKey));
    CMD_S_UpdateAESKey UpdateAESKey;
    ZeroMemory(&UpdateAESKey, sizeof(UpdateAESKey));
    CopyMemory(UpdateAESKey.chUserUpdateAESKey, m_chUserAESKey[wChairID], sizeof(m_chUserAESKey[wChairID]));

    m_pITableFrame->SendTableData(wChairID, SUB_S_UPDATEAESKEY, &UpdateAESKey, sizeof(UpdateAESKey));

    //构造数据
    CMD_S_AddScore AddScore;
    AddScore.lCurrentTimes = (BYTE)m_lCurrentTimes;
    AddScore.wCurrentUser = (BYTE)m_wCurrentUser;
    AddScore.wAddScoreUser = (BYTE)wChairID;
    AddScore.lAddScoreCount = (LONG)lScore;

    //判断状态
    AddScore.wCompareState = (bCompareCard) ? TRUE : FALSE;

    //发送数据
    m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_ADD_SCORE, &AddScore, sizeof(AddScore));
    m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_ADD_SCORE, &AddScore, sizeof(AddScore));

    if(m_pGameVideo)
    {
        m_pGameVideo->AddVideoData(SUB_S_ADD_SCORE, &AddScore);
    }

    //设置定时器
    if(((m_pGameServiceOption->wServerType) & GAME_GENRE_PERSONAL) == 0)
    {
        m_pITableFrame->SetGameTimer(IDI_ADD_SCORE, TIME_ADD_SCORE * 36, 1, 0);
    }

    return true;
}

//扑克分析
void CTableFrameSink::AnalyseStartCard()
{
    //机器人数
    char androids[GAME_PLAYER];
    char players[GAME_PLAYER];
    memset(androids, -1, sizeof(androids));
    memset(players, -1, sizeof(players));
    WORD wAiCount = 0;
    WORD wPlayerCount = 0;
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        //获取用户
        IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(pIServerUserItem != NULL)
        {
            if(m_cbPlayStatus[i] == FALSE)
            {
                continue;
            }
            if(pIServerUserItem->IsAndroidUser()) {
                androids[wAiCount++] = i;
            } else {
                players[wPlayerCount++] = i;
            }
        }
    }
    //全部机器或全部玩家
    if( wPlayerCount == 0 || wAiCount == 0) {
        return;
    }

    //扑克变量
    BYTE cbUserCardData[GAME_PLAYER][MAX_COUNT];
    CopyMemory(cbUserCardData, m_cbHandCardData, sizeof(m_cbHandCardData));
    //变量定义
    WORD wWinUser = INVALID_CHAIR;
    //查找数据
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        //用户过滤
        if(m_cbPlayStatus[i] == FALSE)
        {
            continue;
        }

        //设置用户
        if(wWinUser == INVALID_CHAIR)
        {
            wWinUser = i;
            continue;
        }

        //对比扑克
        if(m_GameLogic.CompareCard(cbUserCardData[i], cbUserCardData[wWinUser], MAX_COUNT) > 0)
        {
            wWinUser = i;
        }
    }
    REF_G(CryptRand, crand);
    bool aiwin = m_pITableFrame->GetTableUserItem(wWinUser)->IsAndroidUser();
    char hit = crand.Number(99);
    char percent = g_lStoragePer1;
    if (g_lRoomStorageCurrent < 0) {
        percent = g_lStoragePer0;
    } else if (g_lRoomStorageCurrent >= g_lStorageMax1Room && g_lRoomStorageCurrent < g_lStorageMax2Room) {
        percent = g_lStorageMul1Room%100;
    } else if (g_lRoomStorageCurrent >= g_lStorageMax2Room) {
        percent = g_lStorageMul2Room%100;
    }
    CString info;
    info.Format(TEXT("AJUST=>[%d]=[%d]=[%d]"), hit, percent, g_lRoomStorageCurrent);
    WriteInfo(TEXT(""), info);
    // 需要交换赢家
    if ((hit < percent && aiwin) || (hit >= percent && !aiwin)) {
        WORD pos = hit%(aiwin ? wPlayerCount:wAiCount);
        char* range = aiwin ? players:androids;
        for (WORD i=pos; i<GAME_PLAYER; i++) {
            char v = range[i];
            if (v != -1 && wWinUser != v) {
                //交换数据
                info.Format(TEXT("AJUST=>from %d %d to %d %d"), wWinUser, aiwin, v, m_pITableFrame->GetTableUserItem(v)->IsAndroidUser());
                WriteInfo(TEXT(""), info);
                BYTE cbTempData[MAX_COUNT];
                CopyMemory(cbTempData, m_cbHandCardData[v], sizeof(BYTE)*MAX_COUNT);
                CopyMemory(m_cbHandCardData[v], m_cbHandCardData[wWinUser], sizeof(BYTE)*MAX_COUNT);
                CopyMemory(m_cbHandCardData[wWinUser], cbTempData, sizeof(BYTE)*MAX_COUNT);
                break;
            }
        }
    }
}

//是否衰减
bool CTableFrameSink::NeedDeductStorage()
{
    //机器人数
    WORD wAiCount = 0;
    WORD wPlayerCount = 0;
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        //获取用户
        IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(pIServerUserItem != NULL)
        {
            if(m_cbPlayStatus[i] == FALSE)
            {
                continue;
            }
            if(pIServerUserItem->IsAndroidUser())
            {
                wAiCount++ ;
            }
            wPlayerCount++;
        }
    }

    return wPlayerCount != wAiCount && wAiCount > 0;

}

//读取配置
void CTableFrameSink::ReadConfigInformation()
{
    //获取自定义配置
    tagCustomRule *pCustomRule = (tagCustomRule *)m_pGameServiceOption->cbCustomRule;
    ASSERT(pCustomRule);

    g_lRoomStorageStart = pCustomRule->lRoomStorageStart;
    g_lRoomStorageCurrent = pCustomRule->lRoomStorageStart;
    g_lStorageDeductRoom = pCustomRule->lRoomStorageDeduct;
    g_lStoragePer0 = pCustomRule->lRoomStoragePer0;
    g_lStoragePer1 = pCustomRule->lRoomStoragePer1;
    g_lStorageMax1Room = pCustomRule->lRoomStorageMax1;
    g_lStorageMul1Room = pCustomRule->lRoomStorageMul1;
    g_lStorageMax2Room = pCustomRule->lRoomStorageMax2;
    g_lStorageMul2Room = pCustomRule->lRoomStorageMul2;

    if(g_lStorageDeductRoom < 0 || g_lStorageDeductRoom > 1000)
    {
        g_lStorageDeductRoom = 0;
    }
    if(g_lStorageDeductRoom > 1000)
    {
        g_lStorageDeductRoom = 1000;
    }
    if(g_lStorageMul1Room < 0 || g_lStorageMul1Room > 100)
    {
        g_lStorageMul1Room = 50;
    }
    if(g_lStorageMul2Room < 0 || g_lStorageMul2Room > 100)
    {
        g_lStorageMul2Room = 80;
    }
}

//更新房间用户信息
void CTableFrameSink::UpdateRoomUserInfo(IServerUserItem *pIServerUserItem, USERACTION userAction)
{
    //变量定义
    ROOMUSERINFO roomUserInfo;
    ZeroMemory(&roomUserInfo, sizeof(roomUserInfo));

    roomUserInfo.dwGameID = pIServerUserItem->GetGameID();
    CopyMemory(&(roomUserInfo.szNickName), pIServerUserItem->GetNickName(), sizeof(roomUserInfo.szNickName));
    roomUserInfo.cbUserStatus = pIServerUserItem->GetUserStatus();
    roomUserInfo.cbGameStatus = m_pITableFrame->GetGameStatus();

    roomUserInfo.bAndroid = pIServerUserItem->IsAndroidUser();

    //用户坐下和重连
    if(userAction == USER_SITDOWN || userAction == USER_RECONNECT)
    {
        roomUserInfo.wChairID = pIServerUserItem->GetChairID();
        roomUserInfo.wTableID = pIServerUserItem->GetTableID() + 1;
    }
    else if(userAction == USER_STANDUP || userAction == USER_OFFLINE)
    {
        roomUserInfo.wChairID = INVALID_CHAIR;
        roomUserInfo.wTableID = INVALID_TABLE;
    }

    g_MapRoomUserInfo.SetAt(pIServerUserItem->GetUserID(), roomUserInfo);

    //遍历映射，删除离开房间的玩家，
    POSITION ptHead = g_MapRoomUserInfo.GetStartPosition();
    DWORD dwUserID = 0;
    ROOMUSERINFO userinfo;
    ZeroMemory(&userinfo, sizeof(userinfo));
    TCHAR szNickName[LEN_NICKNAME];
    ZeroMemory(szNickName, sizeof(szNickName));
    DWORD *pdwRemoveKey	= new DWORD[g_MapRoomUserInfo.GetSize()];
    ZeroMemory(pdwRemoveKey, sizeof(DWORD) * g_MapRoomUserInfo.GetSize());
    WORD wRemoveKeyIndex = 0;

    while(ptHead)
    {
        g_MapRoomUserInfo.GetNextAssoc(ptHead, dwUserID, userinfo);

        if(userinfo.dwGameID == 0 && (_tcscmp(szNickName, userinfo.szNickName) == 0) && userinfo.cbUserStatus == 0)
        {
            pdwRemoveKey[wRemoveKeyIndex++] = dwUserID;
        }

    }

    for(WORD i = 0; i < wRemoveKeyIndex; i++)
    {
        g_MapRoomUserInfo.RemoveKey(pdwRemoveKey[i]);

        CString strtip;
        strtip.Format(TEXT("RemoveKey,wRemoveKeyIndex = %d, g_MapRoomUserInfosize = %d"), wRemoveKeyIndex, g_MapRoomUserInfo.GetSize());
        WriteInfo(L"", strtip);
    }

    delete[] pdwRemoveKey;
}

//更新同桌用户控制
void CTableFrameSink::UpdateUserControl(IServerUserItem *pIServerUserItem)
{
    //变量定义
    POSITION ptListHead;
    POSITION ptTemp;
    ROOMUSERCONTROL roomusercontrol;

    //初始化
    ptListHead = g_ListRoomUserControl.GetHeadPosition();
    ZeroMemory(&roomusercontrol, sizeof(roomusercontrol));

    //遍历链表
    while(ptListHead)
    {
        ptTemp = ptListHead;
        roomusercontrol = g_ListRoomUserControl.GetNext(ptListHead);

        //寻找已存在控制玩家
        if((pIServerUserItem->GetGameID() == roomusercontrol.roomUserInfo.dwGameID) &&
                _tcscmp(pIServerUserItem->GetNickName(), roomusercontrol.roomUserInfo.szNickName) == 0)
        {
            //获取元素
            ROOMUSERCONTROL &tmproomusercontrol = g_ListRoomUserControl.GetAt(ptTemp);

            //重设参数
            tmproomusercontrol.roomUserInfo.wChairID = pIServerUserItem->GetChairID();
            tmproomusercontrol.roomUserInfo.wTableID = m_pITableFrame->GetTableID() + 1;

            return;
        }
    }
}

//除重用户控制
void CTableFrameSink::TravelControlList(ROOMUSERCONTROL keyroomusercontrol)
{
    //变量定义
    POSITION ptListHead;
    POSITION ptTemp;
    ROOMUSERCONTROL roomusercontrol;

    //初始化
    ptListHead = g_ListRoomUserControl.GetHeadPosition();
    ZeroMemory(&roomusercontrol, sizeof(roomusercontrol));

    //遍历链表
    while(ptListHead)
    {
        ptTemp = ptListHead;
        roomusercontrol = g_ListRoomUserControl.GetNext(ptListHead);

        //寻找已存在控制玩家在用一张桌子切换椅子
        if((keyroomusercontrol.roomUserInfo.dwGameID == roomusercontrol.roomUserInfo.dwGameID) &&
                _tcscmp(keyroomusercontrol.roomUserInfo.szNickName, roomusercontrol.roomUserInfo.szNickName) == 0)
        {
            g_ListRoomUserControl.RemoveAt(ptTemp);
        }
    }
}

//是否满足控制条件
void CTableFrameSink::IsSatisfyControl(ROOMUSERINFO &userInfo, bool &bEnableControl)
{
    if(userInfo.wChairID == INVALID_CHAIR || userInfo.wTableID == INVALID_TABLE)
    {
        bEnableControl = FALSE;
        return;
    }

    if(userInfo.cbUserStatus == US_SIT || userInfo.cbUserStatus == US_READY || userInfo.cbUserStatus == US_PLAYING)
    {
        bEnableControl = TRUE;
        return;
    }
    else
    {
        bEnableControl = FALSE;
        return;
    }
}

//分析房间用户控制
bool CTableFrameSink::AnalyseRoomUserControl(ROOMUSERCONTROL &Keyroomusercontrol, POSITION &ptList)
{
    //变量定义
    POSITION ptListHead;
    POSITION ptTemp;
    ROOMUSERCONTROL roomusercontrol;

    //遍历链表
    for(WORD i = 0; i < m_wPlayerCount; i++)
    {
        IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
        if(!pIServerUserItem)
        {
            continue;
        }

        //初始化
        ptListHead = g_ListRoomUserControl.GetHeadPosition();
        ZeroMemory(&roomusercontrol, sizeof(roomusercontrol));

        //遍历链表
        while(ptListHead)
        {
            ptTemp = ptListHead;
            roomusercontrol = g_ListRoomUserControl.GetNext(ptListHead);

            //寻找玩家
            if((pIServerUserItem->GetGameID() == roomusercontrol.roomUserInfo.dwGameID) &&
                    _tcscmp(pIServerUserItem->GetNickName(), roomusercontrol.roomUserInfo.szNickName) == 0)
            {
                //清空控制局数为0的元素
                if(roomusercontrol.userControl.cbControlCount == 0)
                {
                    g_ListRoomUserControl.RemoveAt(ptTemp);
                    break;
                }

                if(roomusercontrol.userControl.control_type == CONTINUE_CANCEL)
                {
                    g_ListRoomUserControl.RemoveAt(ptTemp);
                    break;
                }

                //拷贝数据
                CopyMemory(&Keyroomusercontrol, &roomusercontrol, sizeof(roomusercontrol));
                ptList = ptTemp;

                return true;
            }

        }

    }

    return false;
}

void CTableFrameSink::GetControlTypeString(CONTROL_TYPE &controlType, CString &controlTypestr)
{
    switch(controlType)
    {
    case CONTINUE_WIN:
    {
        controlTypestr = TEXT("控制类型为连赢");
        break;
    }
    case CONTINUE_LOST:
    {
        controlTypestr = TEXT("控制类型为连输");
        break;
    }
    case CONTINUE_CANCEL:
    {
        controlTypestr = TEXT("控制类型为取消控制");
        break;
    }
    }
}

//写日志文件
void CTableFrameSink::WriteInfo(LPCTSTR pszFileName, LPCTSTR pszString)
{
    m_pITableFrame->SendGameMessage(pszString, SMT_GAMELOG);
    // //设置语言区域
    // char *old_locale = _strdup(setlocale(LC_CTYPE, NULL));
    // setlocale(LC_CTYPE, "chs");

    // CStdioFile myFile;
    // CString strFileName;
    // strFileName.Format(TEXT("%s"), pszFileName);
    // BOOL bOpen = myFile.Open(strFileName, CFile::modeReadWrite | CFile::modeCreate | CFile::modeNoTruncate);
    // if(bOpen)
    // {
    //     myFile.SeekToEnd();
    //     myFile.WriteString(pszString);
    //     myFile.Flush();
    //     myFile.Close();
    // }

    // //还原区域设定
    // setlocale(LC_CTYPE, old_locale);
    // free(old_locale);
}

//修改库存
bool CTableFrameSink::UpdateStorage(LONGLONG lScore)
{
    if(!m_bUpdataStorage)
    {
        return true;
    }

    g_lRoomStorageCurrent += lScore;

    //库存为负
    if(g_lRoomStorageCurrent < 0)
    {
        CString str;
        CString strTemp;
        strTemp.Format(TEXT("%d桌 最大下注%I64d 库存为负%I64d 输赢%I64d"), m_pITableFrame->GetTableID() + 1, m_lMaxCellScore, g_lRoomStorageCurrent, lScore);
        str += strTemp;
        for(WORD i = 0; i < m_wPlayerCount; i++)
        {
            if(m_lUserMaxScore[i] > 0)
            {
                strTemp.Format(TEXT("，%d号椅子最大下注%I64d，"), i, m_lUserMaxScore[i]);
                str += strTemp;
                //获取用户
                IServerUserItem *pIServerUserItem = m_pITableFrame->GetTableUserItem(i);
                if(pIServerUserItem != NULL)
                {
                    strTemp.Format(TEXT("UserID=%ld，机器人%d，分数%I64d，下注为%I64d，看牌%d，放弃%d，扑克："), pIServerUserItem->GetUserID(), pIServerUserItem->IsAndroidUser(), pIServerUserItem->GetUserScore(), m_lTableScore[i], m_bMingZhu[i], m_cbGiveUpUser[i]);
                    str += strTemp;
                }
                else
                {
                    strTemp.Format(TEXT("已经离开桌子，下注为%I64d 看牌%d，放弃%d，扑克："), m_lTableScore[i], m_bMingZhu[i], m_cbGiveUpUser[i]);
                    str += strTemp;
                }

                for(int j = 0; j < MAX_COUNT; j++)
                {
                    strTemp.Format(TEXT("%02x "), m_cbHandCardData[i][j]);
                    str += strTemp;
                }
            }
        }

        CString strFileName;
        strFileName.Format(TEXT("诈金花[%s]库存日志.log"), m_pGameServiceOption->szServerName);
        WriteInfo(strFileName, str);
        return false;
    }
    return true;
}

//乱序密钥
void CTableFrameSink::RandAESKey(unsigned char chAESKeyBuffer[], BYTE cbBufferCount)
{
    for(WORD i = 0; i < cbBufferCount; i++)
    {
        chAESKeyBuffer[i] = rand() % 256;
    }
}

//判断积分约占房间
bool CTableFrameSink::IsRoomCardScoreType()
{
    return (m_pITableFrame->GetDataBaseMode() == 1) && (((m_pGameServiceOption->wServerType) & GAME_GENRE_PERSONAL) != 0);
}

//判断金币约占房间
bool CTableFrameSink::IsRoomCardTreasureType()
{
    return (m_pITableFrame->GetDataBaseMode() == 0) && (((m_pGameServiceOption->wServerType) & GAME_GENRE_PERSONAL) != 0);
}

//////////////////////////////////////////////////////////////////////////
